## 125

判断字符串是否回文，去掉标点符号等，不判断大小写

无脑呗

### 法一

```py
class Solution:
    def isPalindrome(self, s):
        s = ''.join(e for e in s if e.isalnum()).lower()
        return s == s[::-1]
```

### 法二

```py
class Solution:
    def isPalindrome(self, s):
        l, r = 0, len(s) - 1
        while l < r:
            while l < r and not s[l].isalnum():
                l += 1
            while l < r and not s[r].isalnum():
                r -= 1
            if s[l].lower() != s[r].lower():
                return False
            l += 1
            r -= 1
        return True
```

## 128

给定一个未排序的数组，寻找一个最长连续的序列的长度

要求，在O(n)时间内完成

```
Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**想法**

在O(n)时间内完成，普通的排序方式肯定是不行的

那么需要的是DP？或者是桶排序？

O(n)的话是需要一维的数组来存放

dp[i]存放的是 

* 当前nums[i]数字结束的最长元素序列的长度？能分解成子问题吗？
* 当前nums[i]数字结束的


[1,100,2] 这类的如何弄？
加上Map？

## 法一

这里将数字放入一个set中，通过迭代，查询并计算每个连续的数字段

```py
class Solution:
    def longestConsecutive(self, nums):
        if not nums:
            return 0
        nums_set = set()
        for num in nums:
            nums_set.add(num)
        res = -float("inf")
        while nums_set:
            num = nums_set.pop()
            pre = num - 1
            nex = num + 1
            # nums_set.remove(num)
            while pre in nums_set:
                nums_set.remove(pre)
                pre = pre - 1
            while nex in nums_set:
                nums_set.remove(nex)
                nex = nex + 1
            if (nex-pre-1) > res:
                res = nex-pre-1
        return res
```

