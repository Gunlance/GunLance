## Java Hashmap

传统的Java HashMap 的实现是**数组+链表**，即使哈希函数取得再好，也很难达到元素百分百均匀分布

譬如，当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。

因此，引入了**红黑树**，在链表长度大于8的时候就对应链表转换为红黑树

其实，目的就是为了减少查找的次数，当链表过长时，转换为树的结构能有效减少查询的次数
<!-- todo 增加跳转链接 -->
譬如，可以将链表转换为AVL数（自平衡二叉查找树），但是AVL树的查找是稳定的，但是插入和删除是比较耗时的，因此才引入了红黑树

至于为什么是8，红黑树的平均查找长度是**log(n)**，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为$\frac{1+2+3+4+5+6+7+8}{8}=4.5$，这才有转换为树的必要。链表长度如果是小于等于6，平均查找长度是3.5，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。

还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。