```py
# 现在有A，B两个序列，两个序列都是拥有n个元素，你有两种操作：

# 1. 从A序列中选择一个非空前缀，再从B序列中选择一个非空前缀，要求选择的这两个前缀的末尾元素相等。把这两个前缀移除，这个操作将花费Cost代价，但是这个操作可以使你得到一颗宝石。

# 2. 您可以重复第1步的操作；最终，您需要花费两个序列剩余元素数量之和大小的代价，移除两个序列中剩下的所有元素（这最后一步是没有宝石的），这时游戏结束。

# 要求总代价不超过Total，且序列中不得有剩余，那么最多可以获得多少宝石。

# 输入
# 输入第一行包含三个正整数n, Total , Cost ,  (1<=n<=5*10^4 , 1<=Total<=3*10^5 , 10^3<=Cost<=10^4)

# 接下来两行，每行n个数，表示A，B序列

# 输出
# 一个数表示最多可以获得的宝石数量


# 样例输入
# 5 10000 1000
# 1 5 4 2 3
# 5 4 3 2 1
# 样例输出
# 3

# 提示
# 按顺序消除末尾为5，4，3的前缀，最后再消除2，1可以获得3颗宝石。


class Soultion:
    def q1(self,A,B,n,total,cost):
        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]
        elimate = [[ False for _ in range(n+1)] for _ in range(n+1)]
        for i in range(1,n+1):
            for j in range(1,n+1):        
                if A[i-1] == B[j-1]:
                    if dp[i-1][j-1] + 1 > max(dp[i-1][j],dp[i][j-1]):
                        dp[i][j] = dp[i-1][j-1] + 1
                        elimate[i][j] = True
                    else:
                        dp[i][j] = max(dp[i-1][j],dp[i][j-1])
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        res = 0
        for i in range(n,0,-1):
            for j in range(n,0,-1):
                if elimate[i][j] and dp[i][j] * cost + 2*n -(i+j) <= total:
                    if dp[i][j] > res:
                        res = dp[i][j]

        return res

        

if __name__ == "__main__":
    import sys
    line = sys.stdin.readline().strip().split(' ')
    n = int(line[0])
    total = int(line[1])
    cost = int(line[2])
    A = sys.stdin.readline().strip()
    B = sys.stdin.readline().strip()

    # A='15423'
    # B='54321'
    # total = 10000
    # cost = 1000
    # n = 5

    print(Soultion().q1(A,B,n,total,cost))
```