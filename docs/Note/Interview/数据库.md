## 关系型数据库

## 非关系型数据库

## 范式

* 第一范式
  * 列的原子性
* 第二范式
  * 实体的属性完全依赖于主关键字
* 第三范式
  * 在1NF基础上，任何非主属性不依赖于其它非主属性


## 数据库事务

* 原子性（Atomic） 组成一个事务的多个数据库操作是一个不可分割的原子单元；只有所有操作执行成功，整个事务才提交，其中一个操作失败，都必须回滚到初始状态。
* 一致性（Consistency）事务操作成功后数据库所处的状态和它的业务规则是一致的；（即数据总额不会被破坏。
如A账户转账100到B账户，无论操作成功与否，A和B的存款总额是不变的）
* 隔离性（Isolation）在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰。（并非是完全无干扰，根据数据库的隔离级别，会产生不同程度的干扰）
* 持久性（Durability）一旦事务提交成功，事务中的数据操作都必须持久化到数据库中；就算数据库崩溃，也必须保证有某种机制恢复。

### 事务隔离

* **脏读**

    * 一个事务读取到另一事务未提交的更新新据。当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作也可能是不正确的。

* **不可重复读**
  
    * 在同一事务中，多次读取同一数据返回的结果有所不同。换句话说就是，后续读取可以读到另一事务已提交的更新数据。
    * 相反，“可重复读”在同一事务中多次读取数据时，能够保证所读数据一样，也就是，后续读取不能读到另一事务已提交的更新数据。

* **幻读**
  
    * 事务T1执行一次查询，然后事务T2新插入一行记录，这行记录恰好可以满足T1所使用的查询的条件。然后T1又使用相同的查询再次对表进行检索，但是此时却看到了事务T2刚才插入的新行。这个新行就称为“幻像”，因为对T1来说这一行就像突然出现的一样。



**参考资料**

* https://www.cnblogs.com/xxoome/p/10081741.html


### 参考资料

* https://www.cnblogs.com/shan-kylin/p/9543294.html

## 数据库优化

* https://blog.51cto.com/lizhenliang/2095526

## Mysql

### 两种引擎

* MyISAM
    * 默认表类型，它是基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且不支持外键，如果执行大量的select，insert MyISAM比较适合。
* InnoDB
    * 支持事务安全的引擎，支持外键、行锁、事务是他的最大特点。如果有大量的update和insert，建议使用InnoDB，特别是针对多个并发和QPS较高的情况

Mysql中InnoDB引擎的主键索引为聚簇索引，MyISAM存储引擎采用非聚集索引


#### InnoDB

InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.下面看一下在REPEATABLE READ隔离级别下,MVCC具体是如何操作的


### 索引


**聚集索引**

指索引项的排序方式和表中数据记录排序方式一致的索引 

聚集索引的顺序就是数据的物理存储顺序。


**非聚集索引**

索引顺序与物理存储顺序不同

**聚簇索引**


#### 联合索引

最左匹配原则