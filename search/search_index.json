{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gunlance \u7c89\u7d2b\u8272\u659c\u4f53 \u4e2a\u4eba\u778e\u60f3 Material color palette \u989c\u8272\u4e3b\u9898 Primary colors \u4e3b\u8272 \u9ed8\u8ba4 Grey \u70b9\u51fb\u8272\u5757\u53ef\u66f4\u6362\u4e3b\u9898\u7684\u4e3b\u8272 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors \u8f85\u52a9\u8272 \u9ed8\u8ba4 red \u70b9\u51fb\u8272\u5757\u66f4\u6362\u4e3b\u9898\u7684\u8f85\u52a9\u8272 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","title":"Gunlance"},{"location":"#gunlance","text":"\u7c89\u7d2b\u8272\u659c\u4f53 \u4e2a\u4eba\u778e\u60f3","title":"Gunlance"},{"location":"#material-color-palette","text":"","title":"Material color palette \u989c\u8272\u4e3b\u9898"},{"location":"#primary-colors","text":"\u9ed8\u8ba4 Grey \u70b9\u51fb\u8272\u5757\u53ef\u66f4\u6362\u4e3b\u9898\u7684\u4e3b\u8272 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","title":"Primary colors \u4e3b\u8272"},{"location":"#accent-colors","text":"\u9ed8\u8ba4 red \u70b9\u51fb\u8272\u5757\u66f4\u6362\u4e3b\u9898\u7684\u8f85\u52a9\u8272 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) })","title":"Accent colors \u8f85\u52a9\u8272"},{"location":"LeetCode/vol 0/001-010/","text":"001 \u4f7f\u7528\u67e5\u8868\u7684\u65b9\u5f0f\u5f88\u5bb9\u6613\u5f97\u51fa 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution ( object ): def twoSum ( self , nums , target ): :type nums: List[int] :type target: int :rtype: List[int] vis = {} for i , num in enumerate ( nums ): diff = target - num if diff in vis : return [ vis [ diff ], i ] vis [ num ] = ` 002 \u6cd5\u4e00 \u94fe\u8868\u6c42\u548c\uff0c\u4e00\u5f00\u59cb\u4f7f\u7528\u4e86\u7b80\u5355\u7c97\u66b4\u7684\u65b9\u6cd5\uff0c\u5148\u6c42\u6bcf\u4e2a\u94fe\u8868\u7684\u503c\uff0c\u518d\u6c42\u548c\uff0c\u63a5\u7740\u8f6c\u6362\u6210\u94fe\u8868 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def getNum ( listNode ): listNode_sum = 0 iter = 1 while listNode : listNode_sum += listNode . val * iter iter *= 10 listNode = listNode . next return listNode_sum def transform ( nums ): ans = ListNode ( nums % 10 ) p = ans nums //= 10 while nums : p . next = ListNode ( nums % 10 ) p = p . next nums //= 10 return ans \u53ef\u7ee7\u7eed\u63d0\u9ad8 \u6cd5\u4e8c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : # @return a ListNode def addTwoNumbers ( self , l1 , l2 ): carry = 0 root = n = ListNode ( 0 ) while l1 or l2 or carry : v1 = v2 = 0 if l1 : v1 = l1 . val l1 = l1 . next if l2 : v2 = l2 . val l2 = l2 . next carry , val = divmod ( v1 + v2 + carry , 10 ) n . next = ListNode ( val ) n = n . next return root . next 003 \u6c42\u5b57\u7b26\u4e32 \u4e0d\u5305\u62ec\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u7684 \u957f\u5ea6 1 2 3 4 Given a string, find the length of the longest substring without repeating characters. Input: abcabcbb Output: 3 Explanation: The answer is abc , with the length of 3. \u731c\u60f3 \u89e3\u6cd5\uff1aDP\u7b97\u6cd5 \u77e9\u9635\u5e94\u8be5\u662f\u4ec0\u4e48\uff0c\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u662f\u4ec0\u4e48\uff1f \u5047\u8bbe\u662f\u4e00\u4e2alist\u5b58\u653e\u72b6\u6001\uff0c\u8be5list\u7684\u6bcf\u4e2a\u5143\u7d20\u4ee3\u8868\u5bf9\u5e94 \u4ee5\u8be5\u5b57\u7b26\u7ed3\u675f\u7684\u5b57\u7b26\u4e32\u7684\u6700\u957f\u4e0d\u91cd\u590d\u5b50\u4e32\u7684\u957f\u5ea6\uff1f \u90a3\u4e48\u4e0b\u4e00\u4e2a\u5143\u7d20\u53ef\u5426\u4f7f\u7528\u4e4b\u524d\u7684\u5143\u7d20\u7684\u4fe1\u606f\uff1f 1 2 3 4 5 6 7 # \u4ee5\u8be5\u5b57\u7b26\u7ed3\u675f\u7684\u5b57\u7b26\u4e32\u7684\u6700\u957f\u4e0d\u91cd\u590d\u5b50\u4e32\u7684\u957f\u5ea6\uff1f # \u90a3\u4e48\u662f\u5426\u9700\u8981\u4e00\u4e2a\u8868\u8bb0\u5f55\u51fa\u73b0\u7684\u4f4d\u7f6e\uff1f # \u5f53\u51fa\u73b0\u91cd\u590d\u7684\u5b57\u7b26\u65f6\uff0c\u67e5\u627e\u4e4b\u524d\u5728\u4e0a\u4e00\u8f6e\u7684\u5bf9\u5e94\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u8ba1\u7b97\u8fd9\u4e00\u8f6e\u7684\u4e0d\u91cd\u590d\u5b57\u7b26\u7684\u5b50\u4e32\u957f\u5ea6\uff0c # \u90a3\u4e48\u5982\u4f55\u8ba1\u7b97\u957f\u5ea6 # \u5f97\u5230\u91cd\u590d\u5b50\u7b26\u7684\u4f4d\u7f6e\uff0c\u5f80\u524d\u67e5\u627e \u4e0a\u4e00\u8f6e\u7684 t m m z u x t \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def lengthOfLongestSubstring ( self , s ): :type s: str :rtype: int maxLength = 0 start = 0 # todo \u8be5\u5b57\u5178\u9700\u8981\u4e00\u4e2a\u66f4\u597d\u7684\u540d\u5b57 subStringDic = {} for index , currentChar in enumerate ( s ): if currentChar in subStringDic and subStringDic [ currentChar ] = start : # \u53d1\u751f\u91cd\u590d\u7684\u5b57\u7b26\uff0c\u91cd\u65b0\u8ba1\u7b97\u65b0\u4e00\u8f6e\u7684\u6700\u957f\u4e0d\u91cd\u590d\u5b50\u4e32 # \u540c\u65f6\uff0c\u786e\u4fdd\u91cd\u590d\u7684\u5b57\u7b26\u4e32\u8981\u5927\u4e8estart\uff0c\u5982 tmmzuxt # \u8be5\u4f8b\u5b50\u4e2d\uff0c\u5982\u679c\u4e0d\u6ee1\u8db3\u5927\u4e8e\u540e\uff0c\u9047\u5230\u6700\u540e\u4e00\u4e2at\u65f6\uff0c\u5c31\u8fdb\u5165\u5224\u65ad\u8bed\u53e5\uff0cstart=0+1=1\u4e86\uff0c\u6ca1\u6709\u8ba1\u7b97\u5230t start = subStringDic [ currentChar ] + 1 else : # \u4e0d\u91cd\u590d\uff0c\u4e0e\u4e4b\u524d\u8bb0\u5f55\u7684\u6700\u5927\u503c\u505a\u6bd4\u8f83\uff0c\u9700\u8981\u66f4\u65b0\u6700\u5927\u503c maxLength = max ( index - start + 1 , maxLength ) subStringDic [ currentChar ] = index return maxLength 004 \u627e\u5230\u4e24\u4e2a\u6392\u5e8f\u6570\u7ec4\u7684\u4e2d\u4f4d\u6570\uff0c\u4e00\u5f00\u59cb\u662f\u60f3set\u540e\u6c42\u5e76\u7136\u540esort\u76f4\u63a5\u8f93\u51fa\u4e2d\u4f4d\u6570\uff0c\u7136\u540e\u53d1\u73b0\u8fd9\u6837\u7684\u4e2d\u4f4d\u6570\u5e76\u4e0d\u662f\u539f\u5148\u4e24\u4e2a\u6570\u7ec4\u7684\u4e2d\u4f4d\u6570\uff0c\u6240\u4ee5\u8be5\u601d\u8def\u653e\u5f03 \u90a3\u4e48\u9700\u8981\u4e0b\u66b4\u529b\u7684\u65b9\u6cd5\u6765\u8f93\u51fa\u4e2d\u4f4d\u6570\uff1f \u7531\u4e8e\u662f\u4e2d\u4f4d\u6570\uff0c\u6709\u4ee5\u4e0b\u51e0\u79cd\u53ef\u80fd \u6cd5\u4e00 005 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u6c42\u5f97\u4e00\u4e2a\u6700\u957f\u7684\u5b50\u56de\u6587\u5b57\u7b26\u4e32 Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000 1 2 3 Input: babad Output: bab Note: aba is also a valid answer. \u731c\u60f3 \u8981\u6c42\u662f\u8fd4\u56de\u4e00\u4e2a\u6700\u957f\u7684\u5b50\u56de\u6587\u5b57\u7b26\u4e32\uff0c\u90a3\u4e48\u9700\u8981\u6ce8\u610f\u7684\u662f \u56de\u6587\u4e32\u7684\u5f62\u5f0f aba aa \u6700\u957f\u5b50\u56de\u6587\u4e32\u7684\u8d77\u59cb\u5730\u5740\u4e0e\u5176\u504f\u79fb\u3001\u7ed3\u675f\u5730\u5740 \u90a3\u4e48\uff0c\u80fd\u5426\u4f7f\u7528\u9996\u5c3e\u4e24\u4e2a\u6307\u9488\u6765\u5411\u4e2d\u5fc3\u79fb\u52a8\u5462\uff1f \u60f3\u4e86\u4e0b\u5927\u6982\u4e0d\u884c\uff0c\u4f8b\u5b50\u5982 ababvda \u6216\u8005\u52a0\u5165DP\u7684\u601d\u60f3\uff1f\u6240\u4ee5\u9700\u8981\u4e00\u4e2a\u65b0\u7684\u5bb9\u5668\u5b58\u653e\u72b6\u6001\uff0c\u8be5\u72b6\u6001\u53ef\u4ee5\u662f\uff1f \u4e00\u7ef4\u6570\u7ec4\uff0c\u72b6\u6001\u8868\u793a\u4ee5\u5f53\u524d\u5b57\u7b26\u5f00\u59cb\u7684\u56de\u6587\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff1f\u6216\u662f\u4ee5\u8be5\u5b57\u7b26\u4e3a\u4e2d\u5fc3\u7684\u957f\u5ea6\uff1f \u611f\u89c9\u4ee5\u8be5\u5b57\u7b26\u4e3a\u4e2d\u5fc3\u957f\u5ea6\u53ef\u884c\uff0c\u4f46\u4e0d\u9002\u7528\u4e0eaaaa\u8fd9\u6837\u5076\u6570\u957f\u5ea6\u56de\u6587\u4e32\uff0c\u6216\u8005\u53ef\u4ee5\u5206\u60c5\u51b5\u8ba8\u8bba \u4e8c\u7ef4\u77e9\u9635\uff1fi\u3001j\u8fd9\u4e24\u5b57\u7b26\u4e4b\u95f4\u662f\u5426\u6709\u56de\u6587\u5b57\u7b26\uff1f \u6cd5\u4e00 \u4f7f\u7528\u4e8c\u7ef4\u6570\u7ec4\u8bb0\u5f55\u72b6\u6001\uff0cdp[i][j]\u8868\u793ai,j\u4e4b\u95f4\u662f\u5426\u662f\u56de\u6587 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution ( object ): def longestPalindrome ( self , s ): dp = [[ 0 ] * len ( s ) for i in range ( len ( s ))] ans = max_length = 0 # i\u5012\u8fc7\u6765\u8ba1\u7b97\u662f\u4e3a\u4e86\u4ece\u5b57\u7b26\u4e32\u5c0f\u5230\u5927 # \u5982\u679ci\u4ece\u5934\u5f00\u59cb\uff0c\u4f1a\u6f0f\u7b97\u60c5\u51b5 for i in range ( len ( s ) - 1 , - 1 , - 1 ): for j in range ( i , len ( s )): if s [ i ] == s [ j ] and ( j - i 3 or dp [ i + 1 ][ j - 1 ] == 1 ): dp [ i ][ j ] = 1 if ans == or max_length j - i + 1 : ans = s [ i : j + 1 ] max_length = j - i + 1 return ans \u6cd5\u4e8c \u8fd9\u91cc\u662f\u4ece\u4e2d\u5fc3\u5411\u4e24\u8fb9\u6269\u5c55 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution ( object ): def longestPalindrome ( self , s ): length = len ( s ) center_odd = 0 center_even = 0 maxRadius = 0 maxLen = 0 if length 2 : return s # \u957f\u5ea6\u4e3a\u5947\u6570 for i in range ( length ): for j in range ( i , length ): # \u8fb9\u754c\u8d85\u51fa if i - ( j - i ) 0 : break # \u5411\u4e24\u8fb9\u6269\u5c55 elif s [ i - ( j - i )] != s [ j ]: break else : if j - i maxRadius : maxRadius = j - i center_odd = i # \u957f\u5ea6\u4e3a\u5076\u6570 for i in range ( length ): for j in range ( i + 1 , length ): # \u8fb9\u754c\u8d85\u51fa if i - ( j - i ) + 1 0 : break # \u5411\u4e24\u8fb9\u6269\u5c55 # center = i = 5 # j = 6, 7, 8, # cp= 5, 4, 3, elif s [ i - ( j - i ) + 1 ] != s [ j ]: break else : if 2 * ( j - i ) maxLen : maxLen = 2 * ( j - i ) center_even = i return s [ center_odd - maxRadius : center_odd + maxRadius + 1 ] if maxLen 2 * maxRadius + 1 else s [ center_even - ( maxLen // 2 ) + 1 : center_even + ( maxLen // 2 ) + 1 ] \u6cd5\u4e09 \u67e5\u627e\u4e86\u8d44\u6599\uff0c\u8fd8\u6709\u4e2a\u9a6c\u62c9\u8f66\u7b97\u6cd5 \u6240\u8c13\u9a6c\u62c9\u8f66\u7b97\u6cd5\uff08manacher\uff09\u662f \u53c2\u8003\u8d44\u6599 https://www.jianshu.com/p/7c3f074b380b \u9519\u8bef Todo \u5206\u6790\u4e3a\u4f55\u51fa\u9519 \u8fd9\u91cc\u51fa\u9519\u4e86\uff0c\u4e0d\u77e5\u9053\u662f\u54ea\u91cc\u7684\u95ee\u9898 \u5df2\u77e5\u7684 i\u4ece\u5934\u5f00\u59cb\uff0c\u5b57\u7b26\u4e32\u5c3e\u90e8\u672a\u8003\u8651\u5230\uff0c\u5e94\u8be5\u4ece\u5c3e\u90e8\u5f00\u59cb \u7591\u8651\uff1a\u4e0d\u662f\u56de\u6587\u5417\uff1f\u4ece\u5934\u4ece\u5c3e\u4e0d\u662f\u4e00\u6837\u4e48\uff1f abbbbbba \u4ece\u5934 a ab bb \u4ece\u5c3e a ba bb bba \u5927\u6982\u5c31\u8fd9\u610f\u601d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution ( object ): def longestPalindrome ( self , s ): :type s: str :rtype: str length = len ( s ) if length 2 : return s dp = [[ False for _ in range ( length )] for _ in range ( length )] # dp[i][j]\u8868\u793a\u5b57\u7b26i,j\u4e4b\u95f4\u662f\u5426\u662f\u56de\u6587\u5b57\u7b26\u4e32 start = 0 maxlength = 0 for i in range ( length ): dp [ i ][ i ] = True for i in range ( length ): for j in range ( i + 1 , length ): # j - i 2 \u6ee1\u8db3 aa aba dp [ i ][ j ] = ( s [ i ] == s [ j ] and ( j - i 2 or dp [ i + 1 ][ j - 1 ])) if j - i + 1 maxlength and dp [ i ][ j ]: start = i maxlength = j - i + 1 return s [ start : start + maxlength + 1 ] \u5176\u4ed6 Todo \u4e3a\u6bdb\u8fd9\u4e2a\u90a3\u4e48\u5feb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 class Solution ( object ): def longestPalindrome ( self , s ): :type s: str :rtype: str max_length = 0 start = 0 if s == s [:: - 1 ]: return s for i in range ( len ( s )): if i - max_length - 1 = 0 and s [ i - max_length - 1 : i + 1 ] == s [ i - max_length - 1 : i + 1 ][:: - 1 ]: start = i - max_length - 1 max_length += 2 # print(i,start, max_length) continue if i - max_length = 0 and s [ i - max_length : i + 1 ] == s [ i - max_length : i + 1 ][:: - 1 ]: start = i - max_length max_length += 1 # print(i,start,max_length) return s [ start : start + max_length ] # class Solution: # def longestPalindrome(self, s): # # :type s: str # :rtype: str # # max_length = 0 # start = 0 # if s == s[::-1]: # return s # # for i in range(len(s)): # if i - max_length - 1 = 0 and s[i - max_length - 1:i + 1] == s[i - max_length - 1:i + 1][::-1]: # start = i - max_length - 1 # max_length += 2 # continue # # if i - max_length = 0 and s[i - max_length:i + 1] == s[i - max_length:i + 1][::-1]: # start = i - max_length # max_length += 1 # return s[start:start + max_length] # Accept O(n) # def longestPalindrome(self, s): # size = len(s) # if size == 1: # return s # if size == 2: # if s[0] == s[1]: # return s # return s[0] # maxp = 1 # ans = s[0] # i = 0 # while i size: # j = i + 1 # # \u786e\u5b9a\u5185\u6838\uff0c\u5728\u540e\u9762\u4ee3\u7801\u4e2dj\u53ef\u4ee5\u81ea\u52a8\u9002\u5e94\u5947\u6570\u5b50\u4e32\u548c\u5076\u6570\u5b50\u4e32 # while j size: # if s[i] == s[j]: # j += 1 # else: # break # k = 0 # # \u5bf9\u79f0\u6269\u5c55 # while i - k - 1 = 0 and j + k = size - 1: # if s[i- k - 1] != s[j + k]: # break # k += 1 # if j - i + 2*k maxp: # maxp = j- i + 2*k # ans = s[i - k:j + k] # if j + k == size - 1: # break # i = j # return ans # TLE O(n^2) # def longestPalindrome(self, s): # if(len(s) =1): # return s # if(len(s)==2): # return s[0] if s[0]!=s[1] else s # # s = s[::-1] # start = 0 # max_len = 1 # length = len(s) # P = [[False for i in range(length)] for i in range(length)] # for i in range(length): # P[i][i] = True # if i (length-1) and s[i]==s[i+1]: # P[i][i+1] = True # start = i # max_len = 2 # for l in range(3,length+1): # for i in range(0,length-l+1): # j = i + l -1 # if P[i+1][j-1] and s[i]==s[j]: # P[i][j] = True # if l max_len: # max_len = l # start = i # return s[start:start+max_len] # TLE O(n^3) # def longestPalindrome(self, s): # # :type s: str # :rtype: str # # if len(s) = 1: # return s # st = 0 # ln = len(s) # re_s = 0 # re_l = 1 # while (st + re_l) = len(s): # while ln re_l: # if self.is_palindrome(s[st:st + ln]) and ln re_l: # print(s[st:st + ln]) # re_s, re_l = st, ln # ln -= 1 # st += 1 # ln = len(s) - st # return s[re_s:re_s + re_l] # def is_palindrome(self, s): # if len(s) == 1: # return True # step = len(s)//2 # for i in range(step): # if s[i] == s[-(i+1)]: # continue # else: # return False # return True # class Solution: # def longestPalindrome(self, s): # # :type s: str # :rtype: str # # maxlen = 1 # start = 0 # if len(s) == 1: # return s # for i in range(len(s)): # lo = i - 1 # hi = i + 1 # while lo = 0 and hi len(s) and s[lo] == s[hi]: # if hi - lo + 1 maxlen: # maxlen = hi - lo + 1 # start = lo # lo -= 1 # hi += 1 # # for i in range(len(s)): # loo = i # hii = i + 1 # while loo = 0 and hii len(s) and s[loo] == s[hii]: # if hii - loo + 1 maxlen: # maxlen = hii - loo + 1 # start = loo # loo -= 1 # hii += 1 # # return s[start:start + maxlen] So = Solution () print ( So . longestPalindrome ( babad )) print ( abcab [ 0 : 0 ]) 006 \u5c06\u5355\u8bcd\u4ee5Z\u5b57\u5f62\u8f93\u51fa\uff0c\u5982 1 2 3 4 5 6 7 8 Input: s = PAYPALISHIRING , numRows = 4 Output: PINALSIGYAHRPI Explanation: P I N A L S I G Y A H R P I 4\u884c\u8f93\u51fa \u731c\u60f3 \u6211\u89c9\u5f97\u5c31\u662f\u66b4\u529b\u505a\u6cd5 \u9996\u5148\u662f\u7279\u6b8a\u7684\u884c\u6570\uff0c\u5982nrow=1 \uff0cnrow len(str) \u7136\u540e\u600e\u4e48\u751f\u6210\u5b57\u7b26\u4e32\uff1f \u9996\u5148\u60f3\u5230\u7684\u662f\u4e8c\u7ef4\u6570\u7ec4 \u7136\u540e\u662f\u4e00\u6a2a\u4e00\u6a2a\u7684\u7684\u9644\u52a0\u4e0a\u53bb 1 2 3 4 5 6 7 8 9 10 11 # nrow = 5 str 0 1 2 3 4 5 6 7 8 9 tmp 0 1 2 3 4 3 2 1 0 1 # nrow = 4 str 0 1 2 3 4 5 6 7 8 9 tmp 0 1 2 3 2 1 0 1 2 3 # nrow = 3 str 0 1 2 3 4 5 6 7 8 9 tmp 0 1 2 1 0 1 2 1 0 1 \u901a\u8fc7\u89c2\u5bdf\uff0c\u5f97\u5230\u6620\u5c04\u5173\u7cfb\uff1f \u6216\u8bb8\u4e0d\u7528\uff1f \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def convert ( self , s , numRows ): if numRows == 1 or numRows = len ( s ): return s L = [ ] * numRows index , step = 0 , 1 for x in s : L [ index ] += x if index == 0 : step = 1 elif index == numRows - 1 : step = - 1 index += step return . join ( L ) \u5176\u4ed6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def convert ( self , s , numRows ): :type s: str :type numRows: int :rtype: str if numRows == 1 : return s ansList = [] gap = 2 * numRows - 2 for i in range ( numRows ): temp1 = i temp2 = gap - i if temp1 == 0 or temp1 == numRows - 1 : while temp1 len ( s ): ansList . append ( s [ temp1 ]) temp1 += gap else : while temp1 len ( s ): ansList . append ( s [ temp1 ]) temp1 += gap if temp2 len ( s ): ansList . append ( s [ temp2 ]) temp2 += gap return . join ( ansList ) 007 \u7ffb\u8f6c\u6570\u5b57 \u867d\u7136\u8bf4\u53ef\u4ee5\u7528python\u672c\u8eab\u7684\u7279\u6027\u6765\u505a\uff0c\u4f46\u6211\u89c9\u5f97\u8fd8\u662f\u7528c\u7684\u65b9\u5f0f\u505a\u6bd4\u8f83\u597d \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def reverse ( self , x ): :type x: int :rtype: int isNegative = False if x 0 : x = - x isNegative = True val = 0 while x != 0 : val = val * 10 + x % 10 x = int ( x / 10 ) res = - val if isNegative else val if res pow ( 2 , 31 ) - 1 or res - pow ( 2 , 31 ): return 0 return res \u5176\u4ed6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def reverse ( self , x ): :type x: int :rtype: int if x 0 : y = - 1 * int ( str ( - x )[:: - 1 ]) else : y = int ( str ( x )[:: - 1 ]) if y 2147483647 or y - 2147483647 : y = 0 return y 008 \u5b9e\u73b0atoi\u51fd\u6570\uff0cstring\u8f6c\u6362\u6210int\u53d8\u91cf \u56de\u60f3\u4e4b\u524datoi\u51fd\u6570\uff0c\u6709\u4ee5\u4e0b\u51e0\u79cd\u529f\u80fd \u53ea\u8bfb\u53d6\u7b2c\u4e00\u4e2a\u53ef\u88ab\u8f6c\u6362\u6210\u6570\u5b57\u7684\u5b57\u7b26\u4e32 \u5982\u679c\u9996\u5b57\u7b26\u662f\u7a7a\u683c\u4ee5\u5916\u7684\u5b57\u7b26\u62a5\u9519 \u8bfb\u53d6 - + \u53f7 \u8fd4\u56deINT \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution ( object ): def myAtoi ( self , str ): :type str: str :rtype: int def isDigit ( char ): if ( 0x30 = ord ( char ) and ord ( char ) = 0x39 ): return True return False if len ( str ) == 0 : return 0 INT_MAX = 2147483647 INT_MIN = - 2147483648 res = 0 start_index = 0 isNegative = False while start_index len ( str ) and str [ start_index ] == : start_index += 1 while start_index len ( str ): if str [ start_index ] == - : isNegative = True start_index += 1 elif str [ start_index ] == + : start_index += 1 while start_index len ( str ) and isDigit ( str [ start_index ]): res = res * 10 + ord ( str [ start_index ]) - 0x30 start_index += 1 if isNegative : res = - res if res INT_MAX : return INT_MAX elif res INT_MIN : return INT_MIN return res return 0 \u5176\u4ed6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Solution ( object ): def myAtoi ( self , str ): :type str: str :rtype: int INT_MAX = 2147483647 INT_MIN = - 2147483648 index = 0 total = 0 sign = 1 # remove the space if len ( str ) == 0 : return 0 while index len ( str ) and str [ index ] == : index += 1 if index len ( str ): if str [ index ] == - : sign = - 1 index += 1 elif str [ index ] == + : index += 1 while index len ( str ): digit = ord ( str [ index ]) - ord ( 0 ) if digit 0 or digit 9 : return total * sign if INT_MAX / 10 sign * total or - (( - INT_MIN ) / 10 ) sign * total or ( INT_MAX / 10 == sign * total and INT_MAX % 10 digit ) or ( - (( - INT_MIN ) / 10 ) == sign * total and ( - INT_MIN ) % 10 digit ): if sign == 1 : return INT_MAX else : return INT_MIN total = total * 10 + digit index += 1 return total * sign # class Solution: # def myAtoi(self, str): # # :type str: str # :rtype: int # # if len(str) == 0: # return 0 # ls = list(str.strip()) # sign = -1 if ls[0] == - else 1 # if ls[0] in [ - , + ]: del ls[0] # ret, i = 0, 0 # while i len(ls) and ls[i].isdigit(): # ret = ret * 10 + ord(ls[i]) - ord( 0 ) # i += 1 # return max(-2 ** 31, min(sign * ret, 2 ** 31 - 1)) print ( Solution () . myAtoi ( 123 )) 009 \u5224\u65ad\u4e00\u4e2a\u6570\u5b57\u662f\u5426\u662f\u56de\u6587\u6570\u5b57 \u8981\u6c42\u662f\u4e0d\u7528toString\u7684\u65b9\u5f0f \u60f3\u6cd5 \u7528\u6570\u5b66\u7684\u65b9\u5f0f\uff1f \u90a3\u4e48\u56de\u6587\u6570\u5b57\u672c\u8eab\u6709\u4ec0\u4e48\u6027\u8d28\uff1f \u966410\u540e\u5165\u6808\uff1f 12323432321 \u7531\u4e24\u7aef\u5411\u4e2d\u5fc3\u79fb\u52a8\uff1f * \u5de6\u7aef\u966410\uff0c\u53f3\u7aef%10 * \u79fb\u52a8\uff1f\u8bb0\u5f55\u6700\u5927\u4f4d\uff1f\u6700\u5927\u4f4d\u53ef\u5728\u5faa\u73af\u65f6\u5019\u8bb0\u5f55 * \u5de6\u7aef a//div % 10 * \u53f3\u7aef a//div % 10 \u7528\u5b57\u7b26\u4e32\u7684\u65b9\u5f0f \u56de\u6587\u5b57\u7b26\u4e32 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def isPalindrome ( self , x ): :type x: int :rtype: bool left , div = x , 1 while left 9 : left = left // 10 div = div * 10 left_div , right_div = div , 1 while x // left_div % 10 == x // right_div % 10 and ( left_div != right_div and left_div != right_div * 10 ): left_div /= 10 right_div *= 10 return x // left_div % 10 == x // right_div % 10 if x = 0 else False \u5176\u4ed6 1 2 3 4 5 6 7 8 9 class Solution : def isPalindrome ( self , x ): div , tmp = 1 , x while tmp = 10 : tmp //= 10 div *= 10 while x and x % 10 == x // div : x , div = x % div // 10 , div // 100 return not x 010 \u5b9e\u73b0\u4e00\u4e2a\u6b63\u5219\u89e3\u6790\u5668","title":"001 010"},{"location":"LeetCode/vol 0/001-010/#001","text":"\u4f7f\u7528\u67e5\u8868\u7684\u65b9\u5f0f\u5f88\u5bb9\u6613\u5f97\u51fa 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution ( object ): def twoSum ( self , nums , target ): :type nums: List[int] :type target: int :rtype: List[int] vis = {} for i , num in enumerate ( nums ): diff = target - num if diff in vis : return [ vis [ diff ], i ] vis [ num ] = `","title":"001"},{"location":"LeetCode/vol 0/001-010/#002","text":"","title":"002"},{"location":"LeetCode/vol 0/001-010/#_1","text":"\u94fe\u8868\u6c42\u548c\uff0c\u4e00\u5f00\u59cb\u4f7f\u7528\u4e86\u7b80\u5355\u7c97\u66b4\u7684\u65b9\u6cd5\uff0c\u5148\u6c42\u6bcf\u4e2a\u94fe\u8868\u7684\u503c\uff0c\u518d\u6c42\u548c\uff0c\u63a5\u7740\u8f6c\u6362\u6210\u94fe\u8868 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def getNum ( listNode ): listNode_sum = 0 iter = 1 while listNode : listNode_sum += listNode . val * iter iter *= 10 listNode = listNode . next return listNode_sum def transform ( nums ): ans = ListNode ( nums % 10 ) p = ans nums //= 10 while nums : p . next = ListNode ( nums % 10 ) p = p . next nums //= 10 return ans \u53ef\u7ee7\u7eed\u63d0\u9ad8","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/001-010/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : # @return a ListNode def addTwoNumbers ( self , l1 , l2 ): carry = 0 root = n = ListNode ( 0 ) while l1 or l2 or carry : v1 = v2 = 0 if l1 : v1 = l1 . val l1 = l1 . next if l2 : v2 = l2 . val l2 = l2 . next carry , val = divmod ( v1 + v2 + carry , 10 ) n . next = ListNode ( val ) n = n . next return root . next","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 0/001-010/#003","text":"\u6c42\u5b57\u7b26\u4e32 \u4e0d\u5305\u62ec\u91cd\u590d\u5b57\u7b26\u7684\u6700\u957f\u5b50\u4e32\u7684 \u957f\u5ea6 1 2 3 4 Given a string, find the length of the longest substring without repeating characters. Input: abcabcbb Output: 3 Explanation: The answer is abc , with the length of 3. \u731c\u60f3 \u89e3\u6cd5\uff1aDP\u7b97\u6cd5 \u77e9\u9635\u5e94\u8be5\u662f\u4ec0\u4e48\uff0c\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u662f\u4ec0\u4e48\uff1f \u5047\u8bbe\u662f\u4e00\u4e2alist\u5b58\u653e\u72b6\u6001\uff0c\u8be5list\u7684\u6bcf\u4e2a\u5143\u7d20\u4ee3\u8868\u5bf9\u5e94 \u4ee5\u8be5\u5b57\u7b26\u7ed3\u675f\u7684\u5b57\u7b26\u4e32\u7684\u6700\u957f\u4e0d\u91cd\u590d\u5b50\u4e32\u7684\u957f\u5ea6\uff1f \u90a3\u4e48\u4e0b\u4e00\u4e2a\u5143\u7d20\u53ef\u5426\u4f7f\u7528\u4e4b\u524d\u7684\u5143\u7d20\u7684\u4fe1\u606f\uff1f 1 2 3 4 5 6 7 # \u4ee5\u8be5\u5b57\u7b26\u7ed3\u675f\u7684\u5b57\u7b26\u4e32\u7684\u6700\u957f\u4e0d\u91cd\u590d\u5b50\u4e32\u7684\u957f\u5ea6\uff1f # \u90a3\u4e48\u662f\u5426\u9700\u8981\u4e00\u4e2a\u8868\u8bb0\u5f55\u51fa\u73b0\u7684\u4f4d\u7f6e\uff1f # \u5f53\u51fa\u73b0\u91cd\u590d\u7684\u5b57\u7b26\u65f6\uff0c\u67e5\u627e\u4e4b\u524d\u5728\u4e0a\u4e00\u8f6e\u7684\u5bf9\u5e94\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u8ba1\u7b97\u8fd9\u4e00\u8f6e\u7684\u4e0d\u91cd\u590d\u5b57\u7b26\u7684\u5b50\u4e32\u957f\u5ea6\uff0c # \u90a3\u4e48\u5982\u4f55\u8ba1\u7b97\u957f\u5ea6 # \u5f97\u5230\u91cd\u590d\u5b50\u7b26\u7684\u4f4d\u7f6e\uff0c\u5f80\u524d\u67e5\u627e \u4e0a\u4e00\u8f6e\u7684 t m m z u x t","title":"003"},{"location":"LeetCode/vol 0/001-010/#_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def lengthOfLongestSubstring ( self , s ): :type s: str :rtype: int maxLength = 0 start = 0 # todo \u8be5\u5b57\u5178\u9700\u8981\u4e00\u4e2a\u66f4\u597d\u7684\u540d\u5b57 subStringDic = {} for index , currentChar in enumerate ( s ): if currentChar in subStringDic and subStringDic [ currentChar ] = start : # \u53d1\u751f\u91cd\u590d\u7684\u5b57\u7b26\uff0c\u91cd\u65b0\u8ba1\u7b97\u65b0\u4e00\u8f6e\u7684\u6700\u957f\u4e0d\u91cd\u590d\u5b50\u4e32 # \u540c\u65f6\uff0c\u786e\u4fdd\u91cd\u590d\u7684\u5b57\u7b26\u4e32\u8981\u5927\u4e8estart\uff0c\u5982 tmmzuxt # \u8be5\u4f8b\u5b50\u4e2d\uff0c\u5982\u679c\u4e0d\u6ee1\u8db3\u5927\u4e8e\u540e\uff0c\u9047\u5230\u6700\u540e\u4e00\u4e2at\u65f6\uff0c\u5c31\u8fdb\u5165\u5224\u65ad\u8bed\u53e5\uff0cstart=0+1=1\u4e86\uff0c\u6ca1\u6709\u8ba1\u7b97\u5230t start = subStringDic [ currentChar ] + 1 else : # \u4e0d\u91cd\u590d\uff0c\u4e0e\u4e4b\u524d\u8bb0\u5f55\u7684\u6700\u5927\u503c\u505a\u6bd4\u8f83\uff0c\u9700\u8981\u66f4\u65b0\u6700\u5927\u503c maxLength = max ( index - start + 1 , maxLength ) subStringDic [ currentChar ] = index return maxLength","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/001-010/#004","text":"\u627e\u5230\u4e24\u4e2a\u6392\u5e8f\u6570\u7ec4\u7684\u4e2d\u4f4d\u6570\uff0c\u4e00\u5f00\u59cb\u662f\u60f3set\u540e\u6c42\u5e76\u7136\u540esort\u76f4\u63a5\u8f93\u51fa\u4e2d\u4f4d\u6570\uff0c\u7136\u540e\u53d1\u73b0\u8fd9\u6837\u7684\u4e2d\u4f4d\u6570\u5e76\u4e0d\u662f\u539f\u5148\u4e24\u4e2a\u6570\u7ec4\u7684\u4e2d\u4f4d\u6570\uff0c\u6240\u4ee5\u8be5\u601d\u8def\u653e\u5f03 \u90a3\u4e48\u9700\u8981\u4e0b\u66b4\u529b\u7684\u65b9\u6cd5\u6765\u8f93\u51fa\u4e2d\u4f4d\u6570\uff1f \u7531\u4e8e\u662f\u4e2d\u4f4d\u6570\uff0c\u6709\u4ee5\u4e0b\u51e0\u79cd\u53ef\u80fd","title":"004"},{"location":"LeetCode/vol 0/001-010/#_4","text":"","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/001-010/#005","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u6c42\u5f97\u4e00\u4e2a\u6700\u957f\u7684\u5b50\u56de\u6587\u5b57\u7b26\u4e32 Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000 1 2 3 Input: babad Output: bab Note: aba is also a valid answer. \u731c\u60f3 \u8981\u6c42\u662f\u8fd4\u56de\u4e00\u4e2a\u6700\u957f\u7684\u5b50\u56de\u6587\u5b57\u7b26\u4e32\uff0c\u90a3\u4e48\u9700\u8981\u6ce8\u610f\u7684\u662f \u56de\u6587\u4e32\u7684\u5f62\u5f0f aba aa \u6700\u957f\u5b50\u56de\u6587\u4e32\u7684\u8d77\u59cb\u5730\u5740\u4e0e\u5176\u504f\u79fb\u3001\u7ed3\u675f\u5730\u5740 \u90a3\u4e48\uff0c\u80fd\u5426\u4f7f\u7528\u9996\u5c3e\u4e24\u4e2a\u6307\u9488\u6765\u5411\u4e2d\u5fc3\u79fb\u52a8\u5462\uff1f \u60f3\u4e86\u4e0b\u5927\u6982\u4e0d\u884c\uff0c\u4f8b\u5b50\u5982 ababvda \u6216\u8005\u52a0\u5165DP\u7684\u601d\u60f3\uff1f\u6240\u4ee5\u9700\u8981\u4e00\u4e2a\u65b0\u7684\u5bb9\u5668\u5b58\u653e\u72b6\u6001\uff0c\u8be5\u72b6\u6001\u53ef\u4ee5\u662f\uff1f \u4e00\u7ef4\u6570\u7ec4\uff0c\u72b6\u6001\u8868\u793a\u4ee5\u5f53\u524d\u5b57\u7b26\u5f00\u59cb\u7684\u56de\u6587\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff1f\u6216\u662f\u4ee5\u8be5\u5b57\u7b26\u4e3a\u4e2d\u5fc3\u7684\u957f\u5ea6\uff1f \u611f\u89c9\u4ee5\u8be5\u5b57\u7b26\u4e3a\u4e2d\u5fc3\u957f\u5ea6\u53ef\u884c\uff0c\u4f46\u4e0d\u9002\u7528\u4e0eaaaa\u8fd9\u6837\u5076\u6570\u957f\u5ea6\u56de\u6587\u4e32\uff0c\u6216\u8005\u53ef\u4ee5\u5206\u60c5\u51b5\u8ba8\u8bba \u4e8c\u7ef4\u77e9\u9635\uff1fi\u3001j\u8fd9\u4e24\u5b57\u7b26\u4e4b\u95f4\u662f\u5426\u6709\u56de\u6587\u5b57\u7b26\uff1f","title":"005"},{"location":"LeetCode/vol 0/001-010/#_5","text":"\u4f7f\u7528\u4e8c\u7ef4\u6570\u7ec4\u8bb0\u5f55\u72b6\u6001\uff0cdp[i][j]\u8868\u793ai,j\u4e4b\u95f4\u662f\u5426\u662f\u56de\u6587 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution ( object ): def longestPalindrome ( self , s ): dp = [[ 0 ] * len ( s ) for i in range ( len ( s ))] ans = max_length = 0 # i\u5012\u8fc7\u6765\u8ba1\u7b97\u662f\u4e3a\u4e86\u4ece\u5b57\u7b26\u4e32\u5c0f\u5230\u5927 # \u5982\u679ci\u4ece\u5934\u5f00\u59cb\uff0c\u4f1a\u6f0f\u7b97\u60c5\u51b5 for i in range ( len ( s ) - 1 , - 1 , - 1 ): for j in range ( i , len ( s )): if s [ i ] == s [ j ] and ( j - i 3 or dp [ i + 1 ][ j - 1 ] == 1 ): dp [ i ][ j ] = 1 if ans == or max_length j - i + 1 : ans = s [ i : j + 1 ] max_length = j - i + 1 return ans","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/001-010/#_6","text":"\u8fd9\u91cc\u662f\u4ece\u4e2d\u5fc3\u5411\u4e24\u8fb9\u6269\u5c55 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution ( object ): def longestPalindrome ( self , s ): length = len ( s ) center_odd = 0 center_even = 0 maxRadius = 0 maxLen = 0 if length 2 : return s # \u957f\u5ea6\u4e3a\u5947\u6570 for i in range ( length ): for j in range ( i , length ): # \u8fb9\u754c\u8d85\u51fa if i - ( j - i ) 0 : break # \u5411\u4e24\u8fb9\u6269\u5c55 elif s [ i - ( j - i )] != s [ j ]: break else : if j - i maxRadius : maxRadius = j - i center_odd = i # \u957f\u5ea6\u4e3a\u5076\u6570 for i in range ( length ): for j in range ( i + 1 , length ): # \u8fb9\u754c\u8d85\u51fa if i - ( j - i ) + 1 0 : break # \u5411\u4e24\u8fb9\u6269\u5c55 # center = i = 5 # j = 6, 7, 8, # cp= 5, 4, 3, elif s [ i - ( j - i ) + 1 ] != s [ j ]: break else : if 2 * ( j - i ) maxLen : maxLen = 2 * ( j - i ) center_even = i return s [ center_odd - maxRadius : center_odd + maxRadius + 1 ] if maxLen 2 * maxRadius + 1 else s [ center_even - ( maxLen // 2 ) + 1 : center_even + ( maxLen // 2 ) + 1 ]","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 0/001-010/#_7","text":"\u67e5\u627e\u4e86\u8d44\u6599\uff0c\u8fd8\u6709\u4e2a\u9a6c\u62c9\u8f66\u7b97\u6cd5 \u6240\u8c13\u9a6c\u62c9\u8f66\u7b97\u6cd5\uff08manacher\uff09\u662f \u53c2\u8003\u8d44\u6599 https://www.jianshu.com/p/7c3f074b380b","title":"\u6cd5\u4e09"},{"location":"LeetCode/vol 0/001-010/#_8","text":"Todo \u5206\u6790\u4e3a\u4f55\u51fa\u9519 \u8fd9\u91cc\u51fa\u9519\u4e86\uff0c\u4e0d\u77e5\u9053\u662f\u54ea\u91cc\u7684\u95ee\u9898 \u5df2\u77e5\u7684 i\u4ece\u5934\u5f00\u59cb\uff0c\u5b57\u7b26\u4e32\u5c3e\u90e8\u672a\u8003\u8651\u5230\uff0c\u5e94\u8be5\u4ece\u5c3e\u90e8\u5f00\u59cb \u7591\u8651\uff1a\u4e0d\u662f\u56de\u6587\u5417\uff1f\u4ece\u5934\u4ece\u5c3e\u4e0d\u662f\u4e00\u6837\u4e48\uff1f abbbbbba \u4ece\u5934 a ab bb \u4ece\u5c3e a ba bb bba \u5927\u6982\u5c31\u8fd9\u610f\u601d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution ( object ): def longestPalindrome ( self , s ): :type s: str :rtype: str length = len ( s ) if length 2 : return s dp = [[ False for _ in range ( length )] for _ in range ( length )] # dp[i][j]\u8868\u793a\u5b57\u7b26i,j\u4e4b\u95f4\u662f\u5426\u662f\u56de\u6587\u5b57\u7b26\u4e32 start = 0 maxlength = 0 for i in range ( length ): dp [ i ][ i ] = True for i in range ( length ): for j in range ( i + 1 , length ): # j - i 2 \u6ee1\u8db3 aa aba dp [ i ][ j ] = ( s [ i ] == s [ j ] and ( j - i 2 or dp [ i + 1 ][ j - 1 ])) if j - i + 1 maxlength and dp [ i ][ j ]: start = i maxlength = j - i + 1 return s [ start : start + maxlength + 1 ]","title":"\u9519\u8bef"},{"location":"LeetCode/vol 0/001-010/#_9","text":"Todo \u4e3a\u6bdb\u8fd9\u4e2a\u90a3\u4e48\u5feb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 class Solution ( object ): def longestPalindrome ( self , s ): :type s: str :rtype: str max_length = 0 start = 0 if s == s [:: - 1 ]: return s for i in range ( len ( s )): if i - max_length - 1 = 0 and s [ i - max_length - 1 : i + 1 ] == s [ i - max_length - 1 : i + 1 ][:: - 1 ]: start = i - max_length - 1 max_length += 2 # print(i,start, max_length) continue if i - max_length = 0 and s [ i - max_length : i + 1 ] == s [ i - max_length : i + 1 ][:: - 1 ]: start = i - max_length max_length += 1 # print(i,start,max_length) return s [ start : start + max_length ] # class Solution: # def longestPalindrome(self, s): # # :type s: str # :rtype: str # # max_length = 0 # start = 0 # if s == s[::-1]: # return s # # for i in range(len(s)): # if i - max_length - 1 = 0 and s[i - max_length - 1:i + 1] == s[i - max_length - 1:i + 1][::-1]: # start = i - max_length - 1 # max_length += 2 # continue # # if i - max_length = 0 and s[i - max_length:i + 1] == s[i - max_length:i + 1][::-1]: # start = i - max_length # max_length += 1 # return s[start:start + max_length] # Accept O(n) # def longestPalindrome(self, s): # size = len(s) # if size == 1: # return s # if size == 2: # if s[0] == s[1]: # return s # return s[0] # maxp = 1 # ans = s[0] # i = 0 # while i size: # j = i + 1 # # \u786e\u5b9a\u5185\u6838\uff0c\u5728\u540e\u9762\u4ee3\u7801\u4e2dj\u53ef\u4ee5\u81ea\u52a8\u9002\u5e94\u5947\u6570\u5b50\u4e32\u548c\u5076\u6570\u5b50\u4e32 # while j size: # if s[i] == s[j]: # j += 1 # else: # break # k = 0 # # \u5bf9\u79f0\u6269\u5c55 # while i - k - 1 = 0 and j + k = size - 1: # if s[i- k - 1] != s[j + k]: # break # k += 1 # if j - i + 2*k maxp: # maxp = j- i + 2*k # ans = s[i - k:j + k] # if j + k == size - 1: # break # i = j # return ans # TLE O(n^2) # def longestPalindrome(self, s): # if(len(s) =1): # return s # if(len(s)==2): # return s[0] if s[0]!=s[1] else s # # s = s[::-1] # start = 0 # max_len = 1 # length = len(s) # P = [[False for i in range(length)] for i in range(length)] # for i in range(length): # P[i][i] = True # if i (length-1) and s[i]==s[i+1]: # P[i][i+1] = True # start = i # max_len = 2 # for l in range(3,length+1): # for i in range(0,length-l+1): # j = i + l -1 # if P[i+1][j-1] and s[i]==s[j]: # P[i][j] = True # if l max_len: # max_len = l # start = i # return s[start:start+max_len] # TLE O(n^3) # def longestPalindrome(self, s): # # :type s: str # :rtype: str # # if len(s) = 1: # return s # st = 0 # ln = len(s) # re_s = 0 # re_l = 1 # while (st + re_l) = len(s): # while ln re_l: # if self.is_palindrome(s[st:st + ln]) and ln re_l: # print(s[st:st + ln]) # re_s, re_l = st, ln # ln -= 1 # st += 1 # ln = len(s) - st # return s[re_s:re_s + re_l] # def is_palindrome(self, s): # if len(s) == 1: # return True # step = len(s)//2 # for i in range(step): # if s[i] == s[-(i+1)]: # continue # else: # return False # return True # class Solution: # def longestPalindrome(self, s): # # :type s: str # :rtype: str # # maxlen = 1 # start = 0 # if len(s) == 1: # return s # for i in range(len(s)): # lo = i - 1 # hi = i + 1 # while lo = 0 and hi len(s) and s[lo] == s[hi]: # if hi - lo + 1 maxlen: # maxlen = hi - lo + 1 # start = lo # lo -= 1 # hi += 1 # # for i in range(len(s)): # loo = i # hii = i + 1 # while loo = 0 and hii len(s) and s[loo] == s[hii]: # if hii - loo + 1 maxlen: # maxlen = hii - loo + 1 # start = loo # loo -= 1 # hii += 1 # # return s[start:start + maxlen] So = Solution () print ( So . longestPalindrome ( babad )) print ( abcab [ 0 : 0 ])","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/001-010/#006","text":"\u5c06\u5355\u8bcd\u4ee5Z\u5b57\u5f62\u8f93\u51fa\uff0c\u5982 1 2 3 4 5 6 7 8 Input: s = PAYPALISHIRING , numRows = 4 Output: PINALSIGYAHRPI Explanation: P I N A L S I G Y A H R P I 4\u884c\u8f93\u51fa \u731c\u60f3 \u6211\u89c9\u5f97\u5c31\u662f\u66b4\u529b\u505a\u6cd5 \u9996\u5148\u662f\u7279\u6b8a\u7684\u884c\u6570\uff0c\u5982nrow=1 \uff0cnrow len(str) \u7136\u540e\u600e\u4e48\u751f\u6210\u5b57\u7b26\u4e32\uff1f \u9996\u5148\u60f3\u5230\u7684\u662f\u4e8c\u7ef4\u6570\u7ec4 \u7136\u540e\u662f\u4e00\u6a2a\u4e00\u6a2a\u7684\u7684\u9644\u52a0\u4e0a\u53bb 1 2 3 4 5 6 7 8 9 10 11 # nrow = 5 str 0 1 2 3 4 5 6 7 8 9 tmp 0 1 2 3 4 3 2 1 0 1 # nrow = 4 str 0 1 2 3 4 5 6 7 8 9 tmp 0 1 2 3 2 1 0 1 2 3 # nrow = 3 str 0 1 2 3 4 5 6 7 8 9 tmp 0 1 2 1 0 1 2 1 0 1 \u901a\u8fc7\u89c2\u5bdf\uff0c\u5f97\u5230\u6620\u5c04\u5173\u7cfb\uff1f \u6216\u8bb8\u4e0d\u7528\uff1f","title":"006"},{"location":"LeetCode/vol 0/001-010/#_10","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def convert ( self , s , numRows ): if numRows == 1 or numRows = len ( s ): return s L = [ ] * numRows index , step = 0 , 1 for x in s : L [ index ] += x if index == 0 : step = 1 elif index == numRows - 1 : step = - 1 index += step return . join ( L )","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/001-010/#_11","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def convert ( self , s , numRows ): :type s: str :type numRows: int :rtype: str if numRows == 1 : return s ansList = [] gap = 2 * numRows - 2 for i in range ( numRows ): temp1 = i temp2 = gap - i if temp1 == 0 or temp1 == numRows - 1 : while temp1 len ( s ): ansList . append ( s [ temp1 ]) temp1 += gap else : while temp1 len ( s ): ansList . append ( s [ temp1 ]) temp1 += gap if temp2 len ( s ): ansList . append ( s [ temp2 ]) temp2 += gap return . join ( ansList )","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/001-010/#007","text":"\u7ffb\u8f6c\u6570\u5b57 \u867d\u7136\u8bf4\u53ef\u4ee5\u7528python\u672c\u8eab\u7684\u7279\u6027\u6765\u505a\uff0c\u4f46\u6211\u89c9\u5f97\u8fd8\u662f\u7528c\u7684\u65b9\u5f0f\u505a\u6bd4\u8f83\u597d","title":"007"},{"location":"LeetCode/vol 0/001-010/#_12","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def reverse ( self , x ): :type x: int :rtype: int isNegative = False if x 0 : x = - x isNegative = True val = 0 while x != 0 : val = val * 10 + x % 10 x = int ( x / 10 ) res = - val if isNegative else val if res pow ( 2 , 31 ) - 1 or res - pow ( 2 , 31 ): return 0 return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/001-010/#_13","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def reverse ( self , x ): :type x: int :rtype: int if x 0 : y = - 1 * int ( str ( - x )[:: - 1 ]) else : y = int ( str ( x )[:: - 1 ]) if y 2147483647 or y - 2147483647 : y = 0 return y","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/001-010/#008","text":"\u5b9e\u73b0atoi\u51fd\u6570\uff0cstring\u8f6c\u6362\u6210int\u53d8\u91cf \u56de\u60f3\u4e4b\u524datoi\u51fd\u6570\uff0c\u6709\u4ee5\u4e0b\u51e0\u79cd\u529f\u80fd \u53ea\u8bfb\u53d6\u7b2c\u4e00\u4e2a\u53ef\u88ab\u8f6c\u6362\u6210\u6570\u5b57\u7684\u5b57\u7b26\u4e32 \u5982\u679c\u9996\u5b57\u7b26\u662f\u7a7a\u683c\u4ee5\u5916\u7684\u5b57\u7b26\u62a5\u9519 \u8bfb\u53d6 - + \u53f7 \u8fd4\u56deINT","title":"008"},{"location":"LeetCode/vol 0/001-010/#_14","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution ( object ): def myAtoi ( self , str ): :type str: str :rtype: int def isDigit ( char ): if ( 0x30 = ord ( char ) and ord ( char ) = 0x39 ): return True return False if len ( str ) == 0 : return 0 INT_MAX = 2147483647 INT_MIN = - 2147483648 res = 0 start_index = 0 isNegative = False while start_index len ( str ) and str [ start_index ] == : start_index += 1 while start_index len ( str ): if str [ start_index ] == - : isNegative = True start_index += 1 elif str [ start_index ] == + : start_index += 1 while start_index len ( str ) and isDigit ( str [ start_index ]): res = res * 10 + ord ( str [ start_index ]) - 0x30 start_index += 1 if isNegative : res = - res if res INT_MAX : return INT_MAX elif res INT_MIN : return INT_MIN return res return 0","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/001-010/#_15","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Solution ( object ): def myAtoi ( self , str ): :type str: str :rtype: int INT_MAX = 2147483647 INT_MIN = - 2147483648 index = 0 total = 0 sign = 1 # remove the space if len ( str ) == 0 : return 0 while index len ( str ) and str [ index ] == : index += 1 if index len ( str ): if str [ index ] == - : sign = - 1 index += 1 elif str [ index ] == + : index += 1 while index len ( str ): digit = ord ( str [ index ]) - ord ( 0 ) if digit 0 or digit 9 : return total * sign if INT_MAX / 10 sign * total or - (( - INT_MIN ) / 10 ) sign * total or ( INT_MAX / 10 == sign * total and INT_MAX % 10 digit ) or ( - (( - INT_MIN ) / 10 ) == sign * total and ( - INT_MIN ) % 10 digit ): if sign == 1 : return INT_MAX else : return INT_MIN total = total * 10 + digit index += 1 return total * sign # class Solution: # def myAtoi(self, str): # # :type str: str # :rtype: int # # if len(str) == 0: # return 0 # ls = list(str.strip()) # sign = -1 if ls[0] == - else 1 # if ls[0] in [ - , + ]: del ls[0] # ret, i = 0, 0 # while i len(ls) and ls[i].isdigit(): # ret = ret * 10 + ord(ls[i]) - ord( 0 ) # i += 1 # return max(-2 ** 31, min(sign * ret, 2 ** 31 - 1)) print ( Solution () . myAtoi ( 123 ))","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/001-010/#009","text":"\u5224\u65ad\u4e00\u4e2a\u6570\u5b57\u662f\u5426\u662f\u56de\u6587\u6570\u5b57 \u8981\u6c42\u662f\u4e0d\u7528toString\u7684\u65b9\u5f0f \u60f3\u6cd5 \u7528\u6570\u5b66\u7684\u65b9\u5f0f\uff1f \u90a3\u4e48\u56de\u6587\u6570\u5b57\u672c\u8eab\u6709\u4ec0\u4e48\u6027\u8d28\uff1f \u966410\u540e\u5165\u6808\uff1f 12323432321 \u7531\u4e24\u7aef\u5411\u4e2d\u5fc3\u79fb\u52a8\uff1f * \u5de6\u7aef\u966410\uff0c\u53f3\u7aef%10 * \u79fb\u52a8\uff1f\u8bb0\u5f55\u6700\u5927\u4f4d\uff1f\u6700\u5927\u4f4d\u53ef\u5728\u5faa\u73af\u65f6\u5019\u8bb0\u5f55 * \u5de6\u7aef a//div % 10 * \u53f3\u7aef a//div % 10 \u7528\u5b57\u7b26\u4e32\u7684\u65b9\u5f0f \u56de\u6587\u5b57\u7b26\u4e32","title":"009"},{"location":"LeetCode/vol 0/001-010/#_16","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def isPalindrome ( self , x ): :type x: int :rtype: bool left , div = x , 1 while left 9 : left = left // 10 div = div * 10 left_div , right_div = div , 1 while x // left_div % 10 == x // right_div % 10 and ( left_div != right_div and left_div != right_div * 10 ): left_div /= 10 right_div *= 10 return x // left_div % 10 == x // right_div % 10 if x = 0 else False","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/001-010/#_17","text":"1 2 3 4 5 6 7 8 9 class Solution : def isPalindrome ( self , x ): div , tmp = 1 , x while tmp = 10 : tmp //= 10 div *= 10 while x and x % 10 == x // div : x , div = x % div // 10 , div // 100 return not x","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/001-010/#010","text":"\u5b9e\u73b0\u4e00\u4e2a\u6b63\u5219\u89e3\u6790\u5668","title":"010"},{"location":"LeetCode/vol 0/011-020/","text":"011 \u6839\u636e\u6240\u7ed9\u7684\u6570\u503c\uff0c\u8fd4\u56de\u6309\u7167\u8fd9\u4e2a\u6570\u503c\u6240\u6784\u6210\u7684\u6700\u591a\u7684\u5bb9\u5668\u7684\u5bb9\u79ef \u8b6c\u5982\u4e0a\u56fe 7 \\times 8=56 7 \\times 8=56 \u60f3\u6cd5 \u5f97\u5230\u5bb9\u79ef\u9700\u8981\u4e24\u4e2a\u503c\uff0c\u66b4\u529b\u7684\u505a\u6cd5\u662f\u904d\u5386 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def maxArea ( self , height ): :type height: List[int] :rtype: int res = 0 for i in range ( len ( height )): for j in range ( i + 1 , len ( height )): tmp = min ( height [ i ], height [ j ]) * ( j - i ) res = max ( res , tmp ) return res \u60f3\u8981\u806a\u660e\u4e00\u70b9\u5f97\u5230\u5bb9\u5668\u7684\u5bb9\u79ef\u9700\u8981 DP\uff1f \u90a3\u4e48\u5982\u4f55\u8bb0\u5f55\u503c\u5462\uff1f\u72b6\u6001\u751f\u6210\u5f0f\u662f\uff1f dp[]? dp[i]\u4e0e\u5176\u5339\u914d\u7684\u5750\u6807\uff1f- \u5982\u4f55\u8ba1\u7b97\uff0c min(height[i],height[dp[i-1]])*abs(i-dp[i-1]),? \u611f\u89c9dp\u4e0d\u884c \u4e8c\u5206 \u4e24\u7aef\u5411\u4e2d\u5fc3\u641c\u7d22\uff1f \u9047\u5230\u5bb9\u79ef\u53d8\u5c11\u5c31\u662f\u6700\u5927\uff1f \u53cd\u4f8b 1 8 8 8 9 1 5- 4 \u6700\u592716 \u8ba1\u7b97\u5dee\u503c\uff0c\u7b26\u5408\u6761\u4ef6\u5c31\u79fb\u52a8\uff1f \u5bb9\u79ef\u53d6\u51b3\u4e8eheight[i],i min(height[i],height[j])*(j-i) \u8fd9\u91cc\u5047\u8bbej\u4e0d\u53d8 \u5982\u679c \u6162\u7740\u600e\u4e48\u611f\u89c9\u53c8\u8dd1\u5230\u4e4b\u524d\u7684\u60f3\u6cd5\u4e86 height[i+1]-height[i] abs(j-(i+i)? \u6216\u8005\u76f4\u63a5\u904d\u5386\uff1f \u6cd5\u4e00 \u91c7\u7528\u4e24\u4e2a\u6307\u9488l\u548cr\uff0c\u521d\u59cb\u5316\u5206\u522b\u6307\u5411\u6570\u7ec4\u7684\u4e24\u7aef\uff0c \u7136\u540e\u5728\u5411\u4e2d\u95f4\u79fb\u52a8\u627e\u5230\u6700\u5927\u5bb9\u91cf\u3002 \u5982\u679cl\u6307\u5411\u7684\u6570\u5b57\u5c0f\uff0c\u5219l\u9700\u8981\u53f3\u79fb\u624d\u6709\u53ef\u80fd\u83b7\u5f97\u66f4\u5927\u5bb9\u91cf\uff0c \u56e0\u4e3a\u6b64\u65f6\u5982\u679c\u5de6\u79fbr\uff0c\u5f97\u5230\u7684\u5bb9\u91cf\u80af\u5b9a\u6bd4\u5de6\u79fbr\u4e4b\u524d\u7684\u5bb9\u91cf\u5c0f \uff08\u9ad8\u5ea6\u5df2\u7ecf\u88ab\u8f83\u5c0f\u7684l\u9650\u5236\u4f4f\u4e86\uff09\u3002 \u5982\u679cr\u6307\u5411\u7684\u6570\u5b57\u5c0f\uff0c\u5219\u9700\u8981\u5de6\u79fbr\u3002 \u8fd9\u6837\uff0c\u5f53l\u548cr\u76f8\u9047\u7684\u65f6\u5019\uff0c\u6700\u5927\u7684\u5bb9\u91cf\u5c31\u662f\u6211\u4eec\u9700\u8981\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def maxArea ( self , height ): :type height: List[int] :rtype: int MAX = 0 right = len ( height ) - 1 left = 0 while right != left : if height [ right ] height [ left ]: area = height [ left ] * ( right - left ) left += 1 else : area = height [ right ] * ( right - left ) right -= 1 MAX = max ( MAX , area ) return MAX 012 int\u53d8\u4e3a\u7f57\u9a6c\u6570\u5b57 \u67e5\u8868\u5c31\u884c\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def intToRoman ( self , num ): :type num: int :rtype: str M = [ , M , MM , MMM ] C = [ , C , CC , CCC , CD , D , DC , DCC , DCCC , CM ] X = [ , X , XX , XXX , XL , L , LX , LXX , LXXX , XC ] I = [ , I , II , III , IV , V , VI , VII , VIII , IX ] return M [ num // 1000 ] + \\ C [( num % 1000 ) // 100 ] + \\ X [( num % 100 ) // 10 ] + \\ I [ num % 10 ] 013 \u7f57\u9a6c\u6570\u5b57\u53d8\u4e3aint 1 to 3999 \u4ece\u540e\u5f80\u524d\u6570\u5457 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def romanToInt ( self , s ): :type s: str :rtype: int dic = { I : 1 , V : 5 , X : 10 , L : 50 , C : 100 , D : 500 , M : 1000 } res = dic [ s [ - 1 ]] for i in range ( len ( s ) - 2 , - 1 , - 1 ): if dic [ s [ i ]] dic [ s [ i + 1 ]]: res -= dic [ s [ i ]] else : res += dic [ s [ i ]] return res \u5176\u4ed6 \u67e5\u8868\u7684\u65b9\u5f0f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution ( object ): def romanToInt ( self , s ): :type s: str :rtype: int sym_to_num = { I : 1 , V : 5 , X : 10 , L : 50 , C : 100 , D : 500 , M : 1000 } special = { IV : 4 , IX : 9 , XL : 40 , XC : 90 , CD : 400 , CM : 900 } i = 0 res = 0 l = len ( s ) while i l : # \u6bcf\u6b21\u5f80\u524d\u68c0\u67e5\u4e00\u4e0b\u6709\u6ca1\u6709\u7279\u6b8a\u7684\u6570\u5b57 if i + 1 l and s [ i : i + 2 ] in special : res += special [ s [ i : i + 2 ]] i += 2 else : res += sym_to_num [ s [ i ]] i += 1 return res 014 \u8fd4\u56de\u4e00\u7ec4\u5b57\u7b26\u4e32\u7684\u6700\u957f\u7684\u516c\u5171\u524d\u7f00 1 2 3 4 5 6 Input: [ flower , flow , flight ] Output: fl Input: [ dog , racecar , car ] Output: Explanation: There is no common prefix among the input strings. \u60f3\u6cd5 DP\uff1f \u5f02\u6216\uff1f python\u4e0d\u652f\u6301\u5b57\u7b26\u4e32\u7684\u5f02\u6216 \u5148\u66b4\u529b\u8bd5\u8bd5\u5427 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def longestCommonPrefix ( self , strs ): :type strs: List[str] :rtype: str if len ( strs ) == 0 : return ans = for i in range ( len ( strs [ 0 ])): # char = strs[0][i] for j in range ( len ( strs )): if i = len ( strs [ j ]) or strs [ 0 ][ i ] != strs [ j ][ i ]: return ans ans += strs [ 0 ][ i ] return ans 015 \u5bf9\u4e8e\u7ed9\u5b9a\u7684\u6570\u7ec4\uff0c\u5224\u65ad\u662f\u5426\u67093\u4e2a\u6570\u76f8\u52a0\u4e3a0\uff0c\u8fd4\u56de\u6240\u6709\u7684\u89e3 \u60f3\u6cd5 \u5b58\u50a8 set \u4f7f\u75282sum\u7684\u601d\u60f3\uff1fhash\u8868\u6765\u5b58\u50a8\u7b49\u4e8e\u96f6\u7684\u6570\u5b57\uff1f \u4e0d\u5bf9\uff0c\u8fd9\u6837\u5c31\u662f\u66b4\u529b\u7684\u505a\u6cd5 \u90a3\u5c31\u66b4\u529b\u8bd5\u8bd5\u5427\uff0c\u7528\u4e24\u4e2adic\u6765\u505a \u6392\u4e2a\u5e8f\u4f1a\u66f4\u597d\uff1f \u5148\u66b4\u529b\u8bd5\u8bd5\uff0c\u4e0d\u8fc7\u90a3\u4e5f\u662f n^3 n^3 \u7684\u590d\u6742\u5ea6 \u6cd5\u4e00 \u6700\u540e\u8fd8\u662f\u75282sum\u7684\u601d\u60f3\u6765\u66b4\u529b\u4e00\u6b21 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def threeSum ( self , nums ): :type nums: List[int] :rtype: List[List[int]] if len ( nums ) 3 : return [] nums . sort () threeSumSet = set () for i , num in enumerate ( nums [: - 2 ]): # \u5bf9\u4e8e\u6bcf\u4e2a\u6570\u5b57\uff0c\u56fa\u5b9a\u4f4f\uff0c\u5efa\u4e00\u4e2a\u8868\u6765\u5b58\u50a8\u5dee\u503c # \u4e0d\u8fc7\u672c\u8eab\u5c31\u662f-num\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\uff1f d = {} for j , nextNum in enumerate ( nums [ i + 1 :]): diff = - num - nextNum if diff in d : threeSumSet . add (( num , nextNum , - nextNum - num )) d [ nextNum ] = j res = [] for single_and in threeSumSet : res . append ( list ( single_and )) return res \u5176\u4ed6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def threeSum ( self , nums ): :type nums: List[int] :rtype: List[List[int]] if len ( nums ) 3 : return [] threeSum_set = set () nums . sort () for i , v in enumerate ( nums [: - 2 ]): if i = 1 and v == nums [ i - 1 ]: continue d = {} for j in nums [ i + 1 :]: if j not in d : d [ - v - j ] = 1 else : threeSum_set . add (( v , - v - j , j )) res = [] for single_ans in threeSum_set : res . append ( list ( single_ans )) return res 016 \u7ed9\u5b9an\u4e2a\u6574\u6570\u548c\u6574\u6570\u76ee\u6807\u7684\u6570\u7ec4nums\uff0c\u5728nums\u4e2d\u627e\u5230\u4e09\u4e2a\u6574\u6570\uff0c\u4f7f\u5f97\u603b\u548c\u6700\u63a5\u8fd1\u76ee\u6807\u3002 \u8fd4\u56de\u603b\u548c \u60f3\u6cd5 3sum\u7684\u53d8\u79cd\uff0c\u6240\u4ee5\u8fd8\u662f\u4f7f\u7528\u5b57\u5178\u6765\u5b58\u50a8 * key \u6570\u5b57num * value \u4f7f\u75283sum\u7684\u601d\u60f3\uff0c\u5efa\u7acb\u4e00\u5b57\u5178\uff0c\u7136\u540e\u5f80\u540e\u904d\u5386\u67e5\u627e \u641c\u7d22\u4e4b\uff0c\u5de6\u79fb\u53f3\u79fb\uff1f diff = target - num - (nums[left]+nums[right]) diff\u5c0f\u4e8e\u96f6 \u9700\u8981\u67e5\u627e\u5f97\u503c\u53d8\u5c0f nums[right] down diff\u5927\u4e8e\u96f6 \u9700\u8981\u67e5\u627e\u5f97\u503c\u53d8\u5927 nums[left] ascend \u76f4\u5230 left =right diff = 0 abs(diff)\u6700\u5c0f\uff0c\u5f53abs(diff)\u53d8\u5927\u65f6\u7ed3\u675f\u5faa\u73af\uff1f -1 -1 2 3 4 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def threeSumClosest ( self , nums , target ): :type nums: List[int] :type target: int :rtype: int if len ( nums ) = 3 : return sum ( nums ) closest = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] nums . sort () distance = abs ( closest - target ) for i in range ( len ( nums ) - 2 ): left = i + 1 right = len ( nums ) - 1 while left right : new_nums_sum = nums [ i ] + nums [ left ] + nums [ right ] current_distance = abs ( new_nums_sum - target ) if current_distance = distance : distance = current_distance closest = new_nums_sum if new_nums_sum target : left += 1 else : right -= 1 return closest \u7591\u95ee \u4e0b\u9762\u4ee3\u7801\u54ea\u91cc\u51fa\u9519\u4e86\u5462\uff1f \u601d\u8def\u662f\u4e00\u81f4\u7684 \u6ce8\u610f\u7f29\u8fdb\uff01\uff01\uff01\uff01 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def threeSumClosest ( self , nums , target ): :type nums: List[int] :type target: int :rtype: int nums . sort () record_diff = float ( inf ) for i , currentNum in enumerate ( nums [: - 2 ]): left = i + 1 right = len ( nums ) - 1 while left right : if currentNum + nums [ left ] + nums [ right ] == target : return target diff = ( currentNum + nums [ left ] + nums [ right ]) - target if abs ( diff ) abs ( record_diff ): record_diff = diff if diff 0 : right = right - 1 else : left = left + 1 return target + record_diff 017 \u7ed9\u5b9a\u4e00\u4e2a\u5305\u542b2-9\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u624b\u673a\u952e\u76d8\u53ef\u80fd\u51fa\u73b0\u7684\u5b57\u7b26 \u611f\u89c9\u4f7f\u7528python\u672c\u8eab\u7684\u6027\u8d28\u5c31\u53ef\u4ee5\u6c42\u5f97\u4e86\uff0c\u4f46\u662f\u6700\u597d\u8fd8\u662f\u4f7f\u7528c\u7684\u601d\u60f3 \u4e00\u5f00\u59cb\u65e0\u6cd5\u786e\u5b9a\u5faa\u73af\u4e2a\u6570\uff0c\u5faa\u73af\u957f\u5ea6 \u7a77\u4e3e\u54af\uff0c\u56de\u6eaf\u54af \u6cd5\u4e00 \u611f\u89c9\u8fd8\u662f\u5bf9\u9012\u5f52\u4e0d\u719f\u6089 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution ( object ): def letterCombinations ( self , digits ): type digits: str rtype: list[str] def dfs ( num , string , res ): if num == length : res . append ( string ) return for letter in dict [ digits [ num ]]: dfs ( num + 1 , string + letter , res ) dict = { 2 : [ a , b , c ], 3 : [ d , e , f ], 4 : [ g , h , i ], 5 : [ j , k , l ], 6 : [ m , n , o ], 7 : [ p , q , r , s ], 8 : [ t , u , v ], 9 : [ w , x , y , z ] } res = [] length = len ( digits ) if length == 0 : return [] dfs ( 0 , , res ) return res for i in Solution () . letterCombinations ( 2352 ): print ( i ) \u5176\u4ed6 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def letterCombinations ( self , digits ): :type digits: str :rtype: List[str] if len ( digits ) == 0 : return [] num_to_char = { 2 : abc , 3 : def , 4 : ghi , 5 : jkl , 6 : mno , 7 : pqrs , 8 : tuv , 9 : wxyz } res = [ i for i in num_to_char [ digits [ 0 ]]] for i in digits [ 1 :]: res = [ m + n for m in res for n in num_to_char [ i ]] return res 018 \u7ed9\u5b9a\u4e00\u4e2atarget\uff0c\u4f7f\u75284\u4e2a\u6570\u5b57\u62fc\u51d1\u5b83 4sum \u6cd5\u4e00 \u6211\u5e72\u8106\u8bd5\u8bd53sum closet\u7b97\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def fourSum ( self , nums , target ): :type nums: List[int] :type target: int :rtype: List[List[int]] nums . sort () res = [] for i in range ( len ( nums ) - 3 ): for j in range ( i + 1 , len ( nums ) - 2 ): start = j + 1 end = len ( nums ) - 1 while start end : value = nums [ i ] + nums [ j ] + nums [ start ] + nums [ end ] if value == target : res . append ([ nums [ i ], nums [ j ], nums [ start ], nums [ end ]]) start += 1 elif value target : start += 1 elif value target : end -= 1 res = list ( set ([ tuple ( t ) for t in res ])) res = [ list ( v ) for v in res ] return res \u5176\u4ed6 Todo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution : def fourSum ( self , nums , target ): :type nums: List[int] :type target: int :rtype: List[List[int]] def findNsum ( nums , target , N , result , results ): if N 2 or len ( nums ) N or nums [ 0 ] * N target or nums [ - 1 ] * N target : return if N == 2 : l = 0 r = len ( nums ) - 1 while l r : s = nums [ l ] + nums [ r ] if s == target : results . append ( result + [ nums [ l ], nums [ r ]]) l += 1 r -= 1 while l r and nums [ l ] == nums [ l - 1 ]: l += 1 while l r and nums [ r ] == nums [ r + 1 ]: r -= 1 elif s target : l += 1 else : r -= 1 else : for i in range ( len ( nums ) - N + 1 ): if i == 0 or ( i 0 and nums [ i ] != nums [ i - 1 ]): findNsum ( nums [ i + 1 ::], target - nums [ i ], N - 1 , result + [ nums [ i ]], results ) results = [] result = [] findNsum ( sorted ( nums ), target , 4 , result , results ) return results 019 \u7ed9\u5b9a\u4ee5\u4e2a\u5355\u94fe\u8868\uff0c\u79fb\u9664\u5012\u6570\u7b2cn\u4e2a\u8282\u70b9 \u5148\u66b4\u529b\u8bd5\u8bd5 \u6709\u4e00\u4e9b\u8fb9\u754c\u6761\u4ef6 \u5012\u6570\u7b2cn\u4e2a\u8282\u70b9\u662fhead\u8282\u70b9 \u5012\u6570\u7b2cn\u4e2a\u8282\u70b9\u662f\u5c3e\u8282\u70b9 \u6cd5\u4e00 \u76f4\u63a5\u66b4\u529b\u4e0a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def removeNthFromEnd ( self , head , n ): :type head: ListNode :type n: int :rtype: ListNode p = head record = [] while p != None : record . append ( p ) p = p . next if len ( record ) == 1 : del ( head ) return None if len ( record ) == n : return record [ 1 ] left = record [ - n - 1 ] left . next = left . next . next record [ - n ] . next = None del ( record [ - n ]) return head \u5176\u4ed6 \u8fd9\u4e2a\u65b9\u5f0f\u6bd4\u66b4\u529b\u7684\u65b9\u5f0f\u806a\u660e\u591a\u4e86 \u9996\u5148right\u5148\u8d70n\u6b65\uff0c\u7136\u540eleft\u5f00\u59cb\u8ba1\u7b97 \u63a5\u7740\u904d\u5386\u4e4b\uff0c\u5982\u679cright\u8d70\u5b8c\u4e86\uff0c\u90a3\u4e48left\u521a\u597d\u5230\u8fbe\u5012\u6570\u7b2cn\u4e2a\u8282\u70b9 \u56e0\u4e3aright\u4e0eleft\u76f8\u5deen\u4e2a\u8282\u70b9\uff0cright\u8d70\u5b8c\u4e86\uff0c\u90a3\u4e48left\u79bb\u5b8c\u6210\u904d\u5386\u8fd8\u6709n\u4e2a\u8282\u70b9\uff0c\u6240\u4ee5\u662f\u5012\u6570\u7b2cn\u4e2a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def removeNthFromEnd ( self , head , n ): :type head: ListNode :type n: int :rtype: ListNode p = head right = p while n 0 : n -= 1 right = right . next left = head if not right : head = head . next return head while right and right . next : right = right . next left = left . next left . next = left . next . next return head 020 \u5224\u65ad\u4e00\u4e2a\u5de6\u53f3\u62ec\u53f7\u662f\u5426\u662f\u5408\u6cd5\u7684 \u611f\u89c9\u4f7f\u7528stack\uff1f \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def isValid ( self , s ): :type s: str :rtype: bool stack = [] left = [ ( , [ , { ] for i in range ( len ( s )): if s [ i ] in left : stack . append ( s [ i ]) continue elif s [ i ] == ) : if len ( stack ) == 0 or stack . pop () != ( : return False elif s [ i ] == ] : if len ( stack ) == 0 or stack . pop () != [ : return False elif s [ i ] == } : if len ( stack ) == 0 or stack . pop () != { : return False return len ( stack ) == 0","title":"011 020"},{"location":"LeetCode/vol 0/011-020/#011","text":"\u6839\u636e\u6240\u7ed9\u7684\u6570\u503c\uff0c\u8fd4\u56de\u6309\u7167\u8fd9\u4e2a\u6570\u503c\u6240\u6784\u6210\u7684\u6700\u591a\u7684\u5bb9\u5668\u7684\u5bb9\u79ef \u8b6c\u5982\u4e0a\u56fe 7 \\times 8=56 7 \\times 8=56 \u60f3\u6cd5 \u5f97\u5230\u5bb9\u79ef\u9700\u8981\u4e24\u4e2a\u503c\uff0c\u66b4\u529b\u7684\u505a\u6cd5\u662f\u904d\u5386 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def maxArea ( self , height ): :type height: List[int] :rtype: int res = 0 for i in range ( len ( height )): for j in range ( i + 1 , len ( height )): tmp = min ( height [ i ], height [ j ]) * ( j - i ) res = max ( res , tmp ) return res \u60f3\u8981\u806a\u660e\u4e00\u70b9\u5f97\u5230\u5bb9\u5668\u7684\u5bb9\u79ef\u9700\u8981 DP\uff1f \u90a3\u4e48\u5982\u4f55\u8bb0\u5f55\u503c\u5462\uff1f\u72b6\u6001\u751f\u6210\u5f0f\u662f\uff1f dp[]? dp[i]\u4e0e\u5176\u5339\u914d\u7684\u5750\u6807\uff1f- \u5982\u4f55\u8ba1\u7b97\uff0c min(height[i],height[dp[i-1]])*abs(i-dp[i-1]),? \u611f\u89c9dp\u4e0d\u884c \u4e8c\u5206 \u4e24\u7aef\u5411\u4e2d\u5fc3\u641c\u7d22\uff1f \u9047\u5230\u5bb9\u79ef\u53d8\u5c11\u5c31\u662f\u6700\u5927\uff1f \u53cd\u4f8b 1 8 8 8 9 1 5- 4 \u6700\u592716 \u8ba1\u7b97\u5dee\u503c\uff0c\u7b26\u5408\u6761\u4ef6\u5c31\u79fb\u52a8\uff1f \u5bb9\u79ef\u53d6\u51b3\u4e8eheight[i],i min(height[i],height[j])*(j-i) \u8fd9\u91cc\u5047\u8bbej\u4e0d\u53d8 \u5982\u679c \u6162\u7740\u600e\u4e48\u611f\u89c9\u53c8\u8dd1\u5230\u4e4b\u524d\u7684\u60f3\u6cd5\u4e86 height[i+1]-height[i] abs(j-(i+i)? \u6216\u8005\u76f4\u63a5\u904d\u5386\uff1f","title":"011"},{"location":"LeetCode/vol 0/011-020/#_1","text":"\u91c7\u7528\u4e24\u4e2a\u6307\u9488l\u548cr\uff0c\u521d\u59cb\u5316\u5206\u522b\u6307\u5411\u6570\u7ec4\u7684\u4e24\u7aef\uff0c \u7136\u540e\u5728\u5411\u4e2d\u95f4\u79fb\u52a8\u627e\u5230\u6700\u5927\u5bb9\u91cf\u3002 \u5982\u679cl\u6307\u5411\u7684\u6570\u5b57\u5c0f\uff0c\u5219l\u9700\u8981\u53f3\u79fb\u624d\u6709\u53ef\u80fd\u83b7\u5f97\u66f4\u5927\u5bb9\u91cf\uff0c \u56e0\u4e3a\u6b64\u65f6\u5982\u679c\u5de6\u79fbr\uff0c\u5f97\u5230\u7684\u5bb9\u91cf\u80af\u5b9a\u6bd4\u5de6\u79fbr\u4e4b\u524d\u7684\u5bb9\u91cf\u5c0f \uff08\u9ad8\u5ea6\u5df2\u7ecf\u88ab\u8f83\u5c0f\u7684l\u9650\u5236\u4f4f\u4e86\uff09\u3002 \u5982\u679cr\u6307\u5411\u7684\u6570\u5b57\u5c0f\uff0c\u5219\u9700\u8981\u5de6\u79fbr\u3002 \u8fd9\u6837\uff0c\u5f53l\u548cr\u76f8\u9047\u7684\u65f6\u5019\uff0c\u6700\u5927\u7684\u5bb9\u91cf\u5c31\u662f\u6211\u4eec\u9700\u8981\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def maxArea ( self , height ): :type height: List[int] :rtype: int MAX = 0 right = len ( height ) - 1 left = 0 while right != left : if height [ right ] height [ left ]: area = height [ left ] * ( right - left ) left += 1 else : area = height [ right ] * ( right - left ) right -= 1 MAX = max ( MAX , area ) return MAX","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/011-020/#012","text":"int\u53d8\u4e3a\u7f57\u9a6c\u6570\u5b57 \u67e5\u8868\u5c31\u884c\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def intToRoman ( self , num ): :type num: int :rtype: str M = [ , M , MM , MMM ] C = [ , C , CC , CCC , CD , D , DC , DCC , DCCC , CM ] X = [ , X , XX , XXX , XL , L , LX , LXX , LXXX , XC ] I = [ , I , II , III , IV , V , VI , VII , VIII , IX ] return M [ num // 1000 ] + \\ C [( num % 1000 ) // 100 ] + \\ X [( num % 100 ) // 10 ] + \\ I [ num % 10 ]","title":"012"},{"location":"LeetCode/vol 0/011-020/#013","text":"\u7f57\u9a6c\u6570\u5b57\u53d8\u4e3aint 1 to 3999 \u4ece\u540e\u5f80\u524d\u6570\u5457","title":"013"},{"location":"LeetCode/vol 0/011-020/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def romanToInt ( self , s ): :type s: str :rtype: int dic = { I : 1 , V : 5 , X : 10 , L : 50 , C : 100 , D : 500 , M : 1000 } res = dic [ s [ - 1 ]] for i in range ( len ( s ) - 2 , - 1 , - 1 ): if dic [ s [ i ]] dic [ s [ i + 1 ]]: res -= dic [ s [ i ]] else : res += dic [ s [ i ]] return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/011-020/#_3","text":"\u67e5\u8868\u7684\u65b9\u5f0f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution ( object ): def romanToInt ( self , s ): :type s: str :rtype: int sym_to_num = { I : 1 , V : 5 , X : 10 , L : 50 , C : 100 , D : 500 , M : 1000 } special = { IV : 4 , IX : 9 , XL : 40 , XC : 90 , CD : 400 , CM : 900 } i = 0 res = 0 l = len ( s ) while i l : # \u6bcf\u6b21\u5f80\u524d\u68c0\u67e5\u4e00\u4e0b\u6709\u6ca1\u6709\u7279\u6b8a\u7684\u6570\u5b57 if i + 1 l and s [ i : i + 2 ] in special : res += special [ s [ i : i + 2 ]] i += 2 else : res += sym_to_num [ s [ i ]] i += 1 return res","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/011-020/#014","text":"\u8fd4\u56de\u4e00\u7ec4\u5b57\u7b26\u4e32\u7684\u6700\u957f\u7684\u516c\u5171\u524d\u7f00 1 2 3 4 5 6 Input: [ flower , flow , flight ] Output: fl Input: [ dog , racecar , car ] Output: Explanation: There is no common prefix among the input strings. \u60f3\u6cd5 DP\uff1f \u5f02\u6216\uff1f python\u4e0d\u652f\u6301\u5b57\u7b26\u4e32\u7684\u5f02\u6216 \u5148\u66b4\u529b\u8bd5\u8bd5\u5427","title":"014"},{"location":"LeetCode/vol 0/011-020/#_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def longestCommonPrefix ( self , strs ): :type strs: List[str] :rtype: str if len ( strs ) == 0 : return ans = for i in range ( len ( strs [ 0 ])): # char = strs[0][i] for j in range ( len ( strs )): if i = len ( strs [ j ]) or strs [ 0 ][ i ] != strs [ j ][ i ]: return ans ans += strs [ 0 ][ i ] return ans","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/011-020/#015","text":"\u5bf9\u4e8e\u7ed9\u5b9a\u7684\u6570\u7ec4\uff0c\u5224\u65ad\u662f\u5426\u67093\u4e2a\u6570\u76f8\u52a0\u4e3a0\uff0c\u8fd4\u56de\u6240\u6709\u7684\u89e3 \u60f3\u6cd5 \u5b58\u50a8 set \u4f7f\u75282sum\u7684\u601d\u60f3\uff1fhash\u8868\u6765\u5b58\u50a8\u7b49\u4e8e\u96f6\u7684\u6570\u5b57\uff1f \u4e0d\u5bf9\uff0c\u8fd9\u6837\u5c31\u662f\u66b4\u529b\u7684\u505a\u6cd5 \u90a3\u5c31\u66b4\u529b\u8bd5\u8bd5\u5427\uff0c\u7528\u4e24\u4e2adic\u6765\u505a \u6392\u4e2a\u5e8f\u4f1a\u66f4\u597d\uff1f \u5148\u66b4\u529b\u8bd5\u8bd5\uff0c\u4e0d\u8fc7\u90a3\u4e5f\u662f n^3 n^3 \u7684\u590d\u6742\u5ea6","title":"015"},{"location":"LeetCode/vol 0/011-020/#_5","text":"\u6700\u540e\u8fd8\u662f\u75282sum\u7684\u601d\u60f3\u6765\u66b4\u529b\u4e00\u6b21 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def threeSum ( self , nums ): :type nums: List[int] :rtype: List[List[int]] if len ( nums ) 3 : return [] nums . sort () threeSumSet = set () for i , num in enumerate ( nums [: - 2 ]): # \u5bf9\u4e8e\u6bcf\u4e2a\u6570\u5b57\uff0c\u56fa\u5b9a\u4f4f\uff0c\u5efa\u4e00\u4e2a\u8868\u6765\u5b58\u50a8\u5dee\u503c # \u4e0d\u8fc7\u672c\u8eab\u5c31\u662f-num\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\uff1f d = {} for j , nextNum in enumerate ( nums [ i + 1 :]): diff = - num - nextNum if diff in d : threeSumSet . add (( num , nextNum , - nextNum - num )) d [ nextNum ] = j res = [] for single_and in threeSumSet : res . append ( list ( single_and )) return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/011-020/#_6","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def threeSum ( self , nums ): :type nums: List[int] :rtype: List[List[int]] if len ( nums ) 3 : return [] threeSum_set = set () nums . sort () for i , v in enumerate ( nums [: - 2 ]): if i = 1 and v == nums [ i - 1 ]: continue d = {} for j in nums [ i + 1 :]: if j not in d : d [ - v - j ] = 1 else : threeSum_set . add (( v , - v - j , j )) res = [] for single_ans in threeSum_set : res . append ( list ( single_ans )) return res","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/011-020/#016","text":"\u7ed9\u5b9an\u4e2a\u6574\u6570\u548c\u6574\u6570\u76ee\u6807\u7684\u6570\u7ec4nums\uff0c\u5728nums\u4e2d\u627e\u5230\u4e09\u4e2a\u6574\u6570\uff0c\u4f7f\u5f97\u603b\u548c\u6700\u63a5\u8fd1\u76ee\u6807\u3002 \u8fd4\u56de\u603b\u548c \u60f3\u6cd5 3sum\u7684\u53d8\u79cd\uff0c\u6240\u4ee5\u8fd8\u662f\u4f7f\u7528\u5b57\u5178\u6765\u5b58\u50a8 * key \u6570\u5b57num * value \u4f7f\u75283sum\u7684\u601d\u60f3\uff0c\u5efa\u7acb\u4e00\u5b57\u5178\uff0c\u7136\u540e\u5f80\u540e\u904d\u5386\u67e5\u627e \u641c\u7d22\u4e4b\uff0c\u5de6\u79fb\u53f3\u79fb\uff1f diff = target - num - (nums[left]+nums[right]) diff\u5c0f\u4e8e\u96f6 \u9700\u8981\u67e5\u627e\u5f97\u503c\u53d8\u5c0f nums[right] down diff\u5927\u4e8e\u96f6 \u9700\u8981\u67e5\u627e\u5f97\u503c\u53d8\u5927 nums[left] ascend \u76f4\u5230 left =right diff = 0 abs(diff)\u6700\u5c0f\uff0c\u5f53abs(diff)\u53d8\u5927\u65f6\u7ed3\u675f\u5faa\u73af\uff1f -1 -1 2 3 4","title":"016"},{"location":"LeetCode/vol 0/011-020/#_7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def threeSumClosest ( self , nums , target ): :type nums: List[int] :type target: int :rtype: int if len ( nums ) = 3 : return sum ( nums ) closest = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] nums . sort () distance = abs ( closest - target ) for i in range ( len ( nums ) - 2 ): left = i + 1 right = len ( nums ) - 1 while left right : new_nums_sum = nums [ i ] + nums [ left ] + nums [ right ] current_distance = abs ( new_nums_sum - target ) if current_distance = distance : distance = current_distance closest = new_nums_sum if new_nums_sum target : left += 1 else : right -= 1 return closest","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/011-020/#_8","text":"\u4e0b\u9762\u4ee3\u7801\u54ea\u91cc\u51fa\u9519\u4e86\u5462\uff1f \u601d\u8def\u662f\u4e00\u81f4\u7684 \u6ce8\u610f\u7f29\u8fdb\uff01\uff01\uff01\uff01 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def threeSumClosest ( self , nums , target ): :type nums: List[int] :type target: int :rtype: int nums . sort () record_diff = float ( inf ) for i , currentNum in enumerate ( nums [: - 2 ]): left = i + 1 right = len ( nums ) - 1 while left right : if currentNum + nums [ left ] + nums [ right ] == target : return target diff = ( currentNum + nums [ left ] + nums [ right ]) - target if abs ( diff ) abs ( record_diff ): record_diff = diff if diff 0 : right = right - 1 else : left = left + 1 return target + record_diff","title":"\u7591\u95ee"},{"location":"LeetCode/vol 0/011-020/#017","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5305\u542b2-9\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u624b\u673a\u952e\u76d8\u53ef\u80fd\u51fa\u73b0\u7684\u5b57\u7b26 \u611f\u89c9\u4f7f\u7528python\u672c\u8eab\u7684\u6027\u8d28\u5c31\u53ef\u4ee5\u6c42\u5f97\u4e86\uff0c\u4f46\u662f\u6700\u597d\u8fd8\u662f\u4f7f\u7528c\u7684\u601d\u60f3 \u4e00\u5f00\u59cb\u65e0\u6cd5\u786e\u5b9a\u5faa\u73af\u4e2a\u6570\uff0c\u5faa\u73af\u957f\u5ea6 \u7a77\u4e3e\u54af\uff0c\u56de\u6eaf\u54af","title":"017"},{"location":"LeetCode/vol 0/011-020/#_9","text":"\u611f\u89c9\u8fd8\u662f\u5bf9\u9012\u5f52\u4e0d\u719f\u6089 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution ( object ): def letterCombinations ( self , digits ): type digits: str rtype: list[str] def dfs ( num , string , res ): if num == length : res . append ( string ) return for letter in dict [ digits [ num ]]: dfs ( num + 1 , string + letter , res ) dict = { 2 : [ a , b , c ], 3 : [ d , e , f ], 4 : [ g , h , i ], 5 : [ j , k , l ], 6 : [ m , n , o ], 7 : [ p , q , r , s ], 8 : [ t , u , v ], 9 : [ w , x , y , z ] } res = [] length = len ( digits ) if length == 0 : return [] dfs ( 0 , , res ) return res for i in Solution () . letterCombinations ( 2352 ): print ( i )","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/011-020/#_10","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def letterCombinations ( self , digits ): :type digits: str :rtype: List[str] if len ( digits ) == 0 : return [] num_to_char = { 2 : abc , 3 : def , 4 : ghi , 5 : jkl , 6 : mno , 7 : pqrs , 8 : tuv , 9 : wxyz } res = [ i for i in num_to_char [ digits [ 0 ]]] for i in digits [ 1 :]: res = [ m + n for m in res for n in num_to_char [ i ]] return res","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/011-020/#018","text":"\u7ed9\u5b9a\u4e00\u4e2atarget\uff0c\u4f7f\u75284\u4e2a\u6570\u5b57\u62fc\u51d1\u5b83 4sum","title":"018"},{"location":"LeetCode/vol 0/011-020/#_11","text":"\u6211\u5e72\u8106\u8bd5\u8bd53sum closet\u7b97\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def fourSum ( self , nums , target ): :type nums: List[int] :type target: int :rtype: List[List[int]] nums . sort () res = [] for i in range ( len ( nums ) - 3 ): for j in range ( i + 1 , len ( nums ) - 2 ): start = j + 1 end = len ( nums ) - 1 while start end : value = nums [ i ] + nums [ j ] + nums [ start ] + nums [ end ] if value == target : res . append ([ nums [ i ], nums [ j ], nums [ start ], nums [ end ]]) start += 1 elif value target : start += 1 elif value target : end -= 1 res = list ( set ([ tuple ( t ) for t in res ])) res = [ list ( v ) for v in res ] return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/011-020/#_12","text":"Todo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution : def fourSum ( self , nums , target ): :type nums: List[int] :type target: int :rtype: List[List[int]] def findNsum ( nums , target , N , result , results ): if N 2 or len ( nums ) N or nums [ 0 ] * N target or nums [ - 1 ] * N target : return if N == 2 : l = 0 r = len ( nums ) - 1 while l r : s = nums [ l ] + nums [ r ] if s == target : results . append ( result + [ nums [ l ], nums [ r ]]) l += 1 r -= 1 while l r and nums [ l ] == nums [ l - 1 ]: l += 1 while l r and nums [ r ] == nums [ r + 1 ]: r -= 1 elif s target : l += 1 else : r -= 1 else : for i in range ( len ( nums ) - N + 1 ): if i == 0 or ( i 0 and nums [ i ] != nums [ i - 1 ]): findNsum ( nums [ i + 1 ::], target - nums [ i ], N - 1 , result + [ nums [ i ]], results ) results = [] result = [] findNsum ( sorted ( nums ), target , 4 , result , results ) return results","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/011-020/#019","text":"\u7ed9\u5b9a\u4ee5\u4e2a\u5355\u94fe\u8868\uff0c\u79fb\u9664\u5012\u6570\u7b2cn\u4e2a\u8282\u70b9 \u5148\u66b4\u529b\u8bd5\u8bd5 \u6709\u4e00\u4e9b\u8fb9\u754c\u6761\u4ef6 \u5012\u6570\u7b2cn\u4e2a\u8282\u70b9\u662fhead\u8282\u70b9 \u5012\u6570\u7b2cn\u4e2a\u8282\u70b9\u662f\u5c3e\u8282\u70b9","title":"019"},{"location":"LeetCode/vol 0/011-020/#_13","text":"\u76f4\u63a5\u66b4\u529b\u4e0a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def removeNthFromEnd ( self , head , n ): :type head: ListNode :type n: int :rtype: ListNode p = head record = [] while p != None : record . append ( p ) p = p . next if len ( record ) == 1 : del ( head ) return None if len ( record ) == n : return record [ 1 ] left = record [ - n - 1 ] left . next = left . next . next record [ - n ] . next = None del ( record [ - n ]) return head","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/011-020/#_14","text":"\u8fd9\u4e2a\u65b9\u5f0f\u6bd4\u66b4\u529b\u7684\u65b9\u5f0f\u806a\u660e\u591a\u4e86 \u9996\u5148right\u5148\u8d70n\u6b65\uff0c\u7136\u540eleft\u5f00\u59cb\u8ba1\u7b97 \u63a5\u7740\u904d\u5386\u4e4b\uff0c\u5982\u679cright\u8d70\u5b8c\u4e86\uff0c\u90a3\u4e48left\u521a\u597d\u5230\u8fbe\u5012\u6570\u7b2cn\u4e2a\u8282\u70b9 \u56e0\u4e3aright\u4e0eleft\u76f8\u5deen\u4e2a\u8282\u70b9\uff0cright\u8d70\u5b8c\u4e86\uff0c\u90a3\u4e48left\u79bb\u5b8c\u6210\u904d\u5386\u8fd8\u6709n\u4e2a\u8282\u70b9\uff0c\u6240\u4ee5\u662f\u5012\u6570\u7b2cn\u4e2a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def removeNthFromEnd ( self , head , n ): :type head: ListNode :type n: int :rtype: ListNode p = head right = p while n 0 : n -= 1 right = right . next left = head if not right : head = head . next return head while right and right . next : right = right . next left = left . next left . next = left . next . next return head","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/011-020/#020","text":"\u5224\u65ad\u4e00\u4e2a\u5de6\u53f3\u62ec\u53f7\u662f\u5426\u662f\u5408\u6cd5\u7684 \u611f\u89c9\u4f7f\u7528stack\uff1f","title":"020"},{"location":"LeetCode/vol 0/011-020/#_15","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def isValid ( self , s ): :type s: str :rtype: bool stack = [] left = [ ( , [ , { ] for i in range ( len ( s )): if s [ i ] in left : stack . append ( s [ i ]) continue elif s [ i ] == ) : if len ( stack ) == 0 or stack . pop () != ( : return False elif s [ i ] == ] : if len ( stack ) == 0 or stack . pop () != [ : return False elif s [ i ] == } : if len ( stack ) == 0 or stack . pop () != { : return False return len ( stack ) == 0","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/021-030/","text":"021 \u94fe\u63a5\u4e24\u4e2a\u5df2\u7ecf\u6392\u5e8f\u597d\u7684\u94fe\u8868\uff0c\u5e76\u4e14\u8ba9\u65b0\u94fe\u8868\u4fdd\u6301\u6392\u5e8f\u597d \u4e0d\u80fd\u65b0\u5efa\u94fe\u8868 1 2 Input: 1- 2- 4, 1- 3- 4 Output: 1- 1- 2- 3- 4- 4 \u60f3\u6cd5 \u904d\u5386\u4e4b\u7136\u540e\u66b4\u529b 0- 2- 6 1- 3- 5 \u540e\u6765\u53d1\u73b0\u4e0b\u9762\u4ee3\u7801\u4e0d\u884c \u6ca1\u6709\u8003\u8651\u4f20\u503c\u4f20\u5f15\u7528\u7684\u95ee\u9898\uff0c\u6240\u4ee5\u51fa\u9519 \u4e0d\u8fc7\u611f\u89c9\u5373\u4f7f\u4e0d\u51fa\u9519\u4e5f\u662f\u65e0\u6cd5\u5de5\u4f5c\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def mergeTwoLists ( self , l1 , l2 ): :type l1: ListNode :type l2: ListNode :rtype: ListNode p1 = l1 p2 = l2 while p1 and p2 : if p1 . val = p2 . val : # \u8fd9\u91cc\u53d6\u5f15\u7528\u4e86\uff0c\u6ca1\u6709\u53d6\u503c\uff0c\u51fa\u9519 recordL1 = p1 p1 . next = p2 p1 = recordL1 . next p2 = p2 . next else : recordL2 = p2 p2 . next = p1 p1 = p2 p1 = p1 . next . next p2 = recordL2 . next return l1 \u6240\u4ee5\u91cd\u65b0\u6784\u601d\uff0c\u60f3\u4e86\u60f3\u8fd8\u662f\u56de\u5f52\u521d\u5fc3\u641e\u4e2a\u4e34\u65f6\u53d8\u91cf\u5427 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def mergeTwoLists ( self , l1 , l2 ): :type l1: ListNode :type l2: ListNode :rtype: ListNode head = ListNode ( HEAD ) p = head p1 = l1 p2 = l2 while p1 and p2 : if p1 . val = p2 . val : p . next = p2 p2 = p2 . next else : p . next = p1 p1 = p1 . next p = p . next p . next = p1 or p2 return head . next 022 \u751f\u6210\u62ec\u53f7\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u6570n\uff0c\u751f\u6210\u6240\u6709\u7b26\u5408\u7531n\u4e2a\u62ec\u53f7\u7684\u5408\u6cd5\u62ec\u53f7\u5b57\u7b26\u4e32 1 2 3 4 5 6 7 8 n = 3 [ ((())) , (()()) , (())() , ()(()) , ()()() ] \u60f3\u6cd5 \u9047\u5230\u62ec\u53f7\u5c31\u7528stack\uff1f \u6cd5\u4e00 \u9996\u5148\u662f\u9012\u5f52 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def generateParenthesis ( self , n ): :type n: int :rtype: List[str] res = [] def dfs ( currentStr , left , right ): if left == n and left == right : res . append ( currentStr ) else : if left n : dfs ( currentStr + ( , left + 1 , right ) if right left : dfs ( currentStr + ) , left , right + 1 ) dfs ( , 0 , 0 ) return res 023 \u5408\u5e76\u591a\u4e2a\u6392\u5e8f\u597d\u7684\u94fe\u8868 \u60f3\u6cd5 \u5148\u6765\u4e2a\u66b4\u529b\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def mergeKLists ( self , lists ): :type lists: List[ListNode] :rtype: ListNode def haveSth ( lists ): for i in lists : if i != None : return True return False head = ListNode ( HEAD ) p = head pLists = [ listnode for listnode in lists ] while haveSth ( pLists ): currentMin = ListNode ( float ( inf )) currentMin_index = 0 for i in range ( len ( pLists )): if pLists [ i ] is not None : if pLists [ i ] . val currentMin . val : currentMin = pLists [ i ] currentMin_index = i # break p . next = currentMin p = p . next if pLists [ currentMin_index ]: pLists [ currentMin_index ] = pLists [ currentMin_index ] . next return head . next \u8be5\u7b97\u6cd5\u7528\u4e869000\u591ams\uff0c\u90a3\u4e48\u9700\u8981\u629b\u5f03\u6216\u8005\u4f18\u5316 \u5176\u5b9e\u53ea\u9700\u8981\u53d6\u4e2a\u6700\u5c0f\u503c\uff0c\u6240\u4ee5\uff0c\u5c0f\u6839\u5806\uff1f \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import heapq class Solution : def mergeKLists ( self , lists ): :type lists: List[ListNode] :rtype: ListNode heap = [] for l in lists : if l != None : heap . append (( l . val , l )) heapq . heapify ( heap ) dummy = ListNode ( 0 ) cur = dummy while heap : _ , h = heapq . heappop ( heap ) cur . next = h cur = cur . next if h . next : heapq . heappush ( heap , ( h . next . val , h . next )) return dummy . next \u4f46\u662f\u7528\u4e86import\uff0c\u6240\u4ee5\u9700\u8981\u81ea\u5df1\u5199\u4e2a\u5c0f\u6839\u5806\uff0c\u6216\u662f\u81ea\u5df1\u8bfbheapq 024 \u4ea4\u6362\u94fe\u8868\u7684\u76f8\u90bb\u7684\u4e24\u4e2a\u8282\u70b9 1 Given 1- 2- 3- 4, you should return the list as 2- 1- 4- 3. \u76f4\u63a5\u66b4\u529b\u4e86 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def swapPairs ( self , head ): :type head: ListNode :rtype: ListNode HEAD = ListNode ( HEAD ) HEAD . next = head p = HEAD while p != None : left = p . next if p . next else False right = p . next . next if p . next else False if left and right : left . next = right . next if right . next else None right . next = left p . next = right p = p . next . next else : break return HEAD . next 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def swapPairs ( self , head ): :type head: ListNode :rtype: ListNode if not head : return None newHead = head . next if head . next else head curr = head prev = None while curr and curr . next : temp = curr . next curr . next = curr . next . next temp . next = curr if prev : prev . next = temp prev = curr curr = curr . next return newHead 025 024\u662f\u4ea4\u6362\u4e24\u4e2a\u76f8\u90bb\u7684\u8282\u70b9\uff0c025\u662f\u7ffb\u8f6c\u8fde\u7eed\u7684n\u4e2a\u8282\u70b9 1 2 3 4 Given this linked list: 1- 2- 3- 4- 5 For k = 2, you should return: 2- 1- 4- 3- 5 For k = 3, you should return: 3- 2- 1- 4- 5 \u60f3\u6cd5 \u7528n\u6765\u63a7\u5236\u5faa\u73af\u6df1\u5ea6 \u5b9e\u73b0\u94fe\u8868\u7684\u7ffb\u8f6c\uff1f \u5efa\u7acb\u4e00\u4e2a\u5faa\u73af\uff0c\u540e\u79fb\u4f4dn\u4e2a\u8282\u70b9\uff0c\u5982\u679c\u5b58\u5728\u9700\u8981\u53cd\u8f6c\uff0c\u5e76\u8bb0\u5f55\u8282\u70b9\u4f4d\u7f6e \u4e00\u5f00\u59cb\u5199\u7684\u662f\u5de6\u95ed\u53f3\u5f00\u7684\uff0c\u5982\u4e0b\uff0c\u5f53head\u4e3a0\uff0cend\u4e3a2\u65f6\uff0c\u53cd\u8f6c\u8282\u70b90\u548c1 1 2 0 - 1 - 2 h e \u4f46\u662f\u51fa\u9519\u4e86\uff0c\u6ca1\u8003\u8651\u597d\u3002\u5904\u4e8e\u4e0b\u9762\u60c5\u51b5\u65f6\uff0c\u4e00\u5f00\u59cb\u7684\u7b97\u6cd5\u5c31\u76f4\u63a5\u8df3\u51fa\u5faa\u73af\u4e86\uff0c\u4f46\u662f\u8fd8\u662f\u9700\u8981\u53cd\u8f6c\u7684 1 2 0 - 1 - None h e \u6240\u4ee5\u9700\u8981\u91cd\u65b0\u5199\u4e2a\uff0c\u6216\u8005\u662f\u6211\u7684\u7b97\u6cd5\u51fa\u9519\u4e86 \u6700\u540e\u8fd8\u662f\u7b97\u6cd5\u51fa\u9519\u4e86 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def reverse ( self , headNode , endNode ): prev = endNode p = headNode while p != endNode : tmp = p . next p . next = prev prev = p p = tmp return prev def reverseKGroup ( self , head , k ): :type head: ListNode :type k: int :rtype: ListNode p = head for i in range ( k ): if not p : return head p = p . next newHead = reverse ( head , p ) head . next = self . reverseKGroup ( p , k ) return newHead \u9519\u8bef\u4ee3\u7801 Todo \u6539\u9519 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution : def reverse ( self , headNode , endNode ): TMPHEAD = ListNode ( HEAD ) TMPHEAD . next = endNode p = headNode while p != endNode : currentNode = p p = p . next currentNode . next = TMPHEAD . next TMPHEAD . next = currentNode return TMPHEAD . next def getKthNode ( self , head , k ): p = head for _ in range ( k ): p = p . next if p is None : break return p def reverseKGroup ( self , head , k ): :type head: ListNode :type k: int :rtype: ListNode if not head or head . val == None : return HEAD = ListNode ( HEAD ) HEAD . next = head link = HEAD p = head endNode = self . getKthNode ( p , k ) while p and endNode : headNode = self . reverse ( p , endNode ) p = p . next endNode = self . getKthNode ( p , k ) link . next = headNode link = self . getKthNode ( link , k ) return HEAD . next \u4ee3\u7801\u81c3\u80bf\uff0c\u6839\u636e\u4e4b\u524d\u7684\u53d8\u5316\u6539\u52a8\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def reverse ( self , headNode , endNode ): TMPHEAD = ListNode ( HEAD ) TMPHEAD . next = endNode p = headNode while p != endNode : currentNode = p p = p . next currentNode . next = TMPHEAD . next TMPHEAD . next = currentNode return TMPHEAD . next def reverseKGroup ( self , head , k ): :type head: ListNode :type k: int :rtype: ListNode p = head for i in range ( k ): if p is None : return head p = p . next newHead = self . reverse ( head , p ) head . next = self . reverseKGroup ( p , k ) return newHead \u603b\u7ed3 \u94fe\u8868\u53cd\u8f6c\u8fd8\u662f\u4e0d\u6e05\u6670\uff0c\u867d\u7136\u601d\u8def\u4e00\u6837\u4f46\u8fd8\u662f\u82b1\u4e86\u70b9\u65f6\u95f4\u91cd\u65b0\u7406\u89e3 \u5fd8\u8bb0\u4f7f\u7528\u9012\u5f52 026 \u7ed9\u5b9a\u4e00\u4e2a**\u6392\u597d\u5e8f**\u7684\u6570\u7ec4\uff0c\u5220\u9664\u91cd\u590d\u9879\uff0c\u7ed9\u51fa\u5220\u9664\u91cd\u590d\u9879\u540e\u7684\u957f\u5ea6 \u8981\u6c42\uff0c\u989d\u5916\u7684O(1)\u5185\u5b58 \u5751 \u4e3a\u4ec0\u4e48\u8fd4\u56de\u503c\u662f\u4e00\u4e2a\u6574\u6570\u4f46\u4f60\u7684\u7b54\u6848\u662f\u4e00\u4e2a\u6570\u7ec4\uff1f \u8bf7\u6ce8\u610f\uff0c\u8f93\u5165\u6570\u7ec4\u662f\u901a\u8fc7\u5f15\u7528\u4f20\u5165\u7684\uff0c\u8fd9\u610f\u5473\u7740\u8c03\u7528\u8005\u4e5f\u53ef\u4ee5\u77e5\u9053\u5bf9\u8f93\u5165\u6570\u7ec4\u7684\u4fee\u6539\u3002 \u4f7f\u7528\u8fd4\u56de\u7684\u957f\u5ea6\uff0c\u8fd9\u56de\u6253\u5370\u51fa\u7b2c\u4e00\u4e2a\u7b2ci\u5927\u7684\u503c \u4e5f\u5c31\u662f\u8bf4\uff0c\u4e0d\u662f\u8fd4\u56de\u4e00\u4e2a\u6570\uff0c\u662f\u5bf9\u8fd9\u4e2a\u6570\u7ec4\u8fdb\u884c\u64cd\u4f5c\uff0c\u540c\u65f6\uff0c\u4e0d\u80fd\u4f7f\u7528\u4e00\u4e2a\u989d\u5916\u6570\u7ec4\u6765\u653e\u7f6e\u6570 \u60f3\u6cd5 \u66b4\u529b\u904d\u5386\u8bd5\u8bd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def removeDuplicates ( self , nums ): :type nums: List[int] :rtype: int if len ( nums ) = 1 : return len ( nums ) i = 1 while i len ( nums ): if nums [ i ] == nums [ i - 1 ]: del ( nums [ i ]) else : i += 1 return len ( nums ) \u8fd9\u91cc\u7528\u4e86python\u672c\u8eab\u7684\u51fd\u6570 \u90a3\u4e48\u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5206\u914d\u597d\u7684index\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def removeDuplicates ( self , nums ): :type nums: List[int] :rtype: int if len ( nums ) = 1 : return len ( nums ) index = 1 for i in range ( 1 , len ( nums )): if nums [ i ] nums [ i - 1 ]: nums [ index ] = nums [ i ] index += 1 # del(nums[index:]) return index 027 \u7ed9\u5b9a\u4ee5\u4e2a\u6570\u7ec4nums\u548c\u6570\u5b57val\uff0c\u5c06nums\u5185\u7684\u6240\u6709\u503c\u4e3aval\u7684\u5b9e\u4f8b\u5220\u9664\u6389 \u8981\u6c42\u4e0e026\u7684\u4e00\u6837 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution ( object ): def removeElement ( self , nums , val ): :type nums: List[int] :type val: int :rtype: int # start, end = 0, len(nums) - 1 # while start = end: # if nums[start] == val: # nums[start], nums[end], end = nums[end], nums[start], end - 1 # else: # start += 1 # return start begin = 0 for i in range ( len ( nums )): if nums [ i ] != val : nums [ begin ] = nums [ i ] begin += 1 return begin 028 \u5b9e\u73b0\u51fd\u6570\u6765\u5f97\u5230\u5b50\u5b57\u7b26\u4e32\u5728\u5b57\u7b26\u4e32\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e 1 2 3 4 5 Input: haystack = hello , needle = ll Output: 2 Input: haystack = aaaaa , needle = bba Output: -1 \u60f3\u6cd5 \u6211\u600e\u4e48\u611f\u89c9\u548c026\uff0c027\u7684\u9898\u76ee\u5dee\u4e0d\u591a \u4ec0\u4e48\u9898\u5148\u66b4\u529b\u8bd5\u8bd5 \u4e00\u5f00\u59cb\u7684\u66b4\u529b\u601d\u8def\u51fa\u9519\u4e86\uff0c\u5f53\u78b0\u5230\u4e0b\u9762\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u65f6\u5019\u5c31\u51fa\u9519\u4e86 \u4e00\u5f00\u59cb\u7684\u66b4\u529b\u601d\u8def\u662f\u5728haystack\u627eneedle[0]\u7684\u5b57\u7b26\uff0c\u7136\u540e\u9010\u4e2a\u68c0\u67e5\uff0c\u4f46\u662f\u6ca1\u6709\u8003\u8651\u7c7b\u4f3c\u4e0b\u9762\u53ef\u80fd\u6709\u516c\u5171\u5f00\u5934\u5b57\u7b26\u4e32\u7684\u60c5\u51b5 1 2 mississippi issipi \u90a3\u4e48\u52bf\u5fc5\u8981\u6362\u4e2a\u66b4\u529b\u601d\u8def\uff0c\u6bd4\u5982\u66f4\u539f\u59cb\u7684\u65b9\u5f0f\uff0c\u4f46\u662f\u8fd9\u6837\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u592a\u9ad8\u4e86 \u90a3\u4e48\u80fd\u5426\u4e0aDP\u5462\uff1f \u9700\u8981\u4f7f\u7528\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4dp[i][j]\uff1f\u8868\u793ahaystack[i]\u4e2dneedle[j]\u7684\u51fa\u73b0\u7684\u4f4d\u7f6e\uff1f \u90a3\u4e48\u5982\u4f55\u8fed\u4ee3\u5462\uff0c\u521d\u59cb\u72b6\u6001\uff1f 029 \u7ed9\u5b9a\u4e24\u4e2a\u6574\u6570\u9664\u6570\u4e0e\u4f59\u6570\uff0c\u8fdb\u884c\u9664\u6cd5\u800c\u4e0d\u4f7f\u7528 / , * , % \u901a\u8fc7\u79fb\u4f4d\u6765\u505a\uff1f 030 \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5728\u8fd9\u5b57\u7b26\u4e32\u4e2d\u67e5\u627e \u4e00\u4e2a\u7531\u76f8\u540c\u957f\u5ea6\u5b57\u7b26\u4e32\u6784\u6210\u7684\u5217\u8868 \u7684\u6240\u6709\u5bf9\u5e94\u6210\u5458\u7684\u5728\u6bcd\u5b57\u7b26\u4e32\u7684\u7d22\u5f15","title":"021 030"},{"location":"LeetCode/vol 0/021-030/#021","text":"\u94fe\u63a5\u4e24\u4e2a\u5df2\u7ecf\u6392\u5e8f\u597d\u7684\u94fe\u8868\uff0c\u5e76\u4e14\u8ba9\u65b0\u94fe\u8868\u4fdd\u6301\u6392\u5e8f\u597d \u4e0d\u80fd\u65b0\u5efa\u94fe\u8868 1 2 Input: 1- 2- 4, 1- 3- 4 Output: 1- 1- 2- 3- 4- 4 \u60f3\u6cd5 \u904d\u5386\u4e4b\u7136\u540e\u66b4\u529b 0- 2- 6 1- 3- 5 \u540e\u6765\u53d1\u73b0\u4e0b\u9762\u4ee3\u7801\u4e0d\u884c \u6ca1\u6709\u8003\u8651\u4f20\u503c\u4f20\u5f15\u7528\u7684\u95ee\u9898\uff0c\u6240\u4ee5\u51fa\u9519 \u4e0d\u8fc7\u611f\u89c9\u5373\u4f7f\u4e0d\u51fa\u9519\u4e5f\u662f\u65e0\u6cd5\u5de5\u4f5c\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def mergeTwoLists ( self , l1 , l2 ): :type l1: ListNode :type l2: ListNode :rtype: ListNode p1 = l1 p2 = l2 while p1 and p2 : if p1 . val = p2 . val : # \u8fd9\u91cc\u53d6\u5f15\u7528\u4e86\uff0c\u6ca1\u6709\u53d6\u503c\uff0c\u51fa\u9519 recordL1 = p1 p1 . next = p2 p1 = recordL1 . next p2 = p2 . next else : recordL2 = p2 p2 . next = p1 p1 = p2 p1 = p1 . next . next p2 = recordL2 . next return l1 \u6240\u4ee5\u91cd\u65b0\u6784\u601d\uff0c\u60f3\u4e86\u60f3\u8fd8\u662f\u56de\u5f52\u521d\u5fc3\u641e\u4e2a\u4e34\u65f6\u53d8\u91cf\u5427","title":"021"},{"location":"LeetCode/vol 0/021-030/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def mergeTwoLists ( self , l1 , l2 ): :type l1: ListNode :type l2: ListNode :rtype: ListNode head = ListNode ( HEAD ) p = head p1 = l1 p2 = l2 while p1 and p2 : if p1 . val = p2 . val : p . next = p2 p2 = p2 . next else : p . next = p1 p1 = p1 . next p = p . next p . next = p1 or p2 return head . next","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/021-030/#022","text":"\u751f\u6210\u62ec\u53f7\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u6570n\uff0c\u751f\u6210\u6240\u6709\u7b26\u5408\u7531n\u4e2a\u62ec\u53f7\u7684\u5408\u6cd5\u62ec\u53f7\u5b57\u7b26\u4e32 1 2 3 4 5 6 7 8 n = 3 [ ((())) , (()()) , (())() , ()(()) , ()()() ] \u60f3\u6cd5 \u9047\u5230\u62ec\u53f7\u5c31\u7528stack\uff1f","title":"022"},{"location":"LeetCode/vol 0/021-030/#_2","text":"\u9996\u5148\u662f\u9012\u5f52 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def generateParenthesis ( self , n ): :type n: int :rtype: List[str] res = [] def dfs ( currentStr , left , right ): if left == n and left == right : res . append ( currentStr ) else : if left n : dfs ( currentStr + ( , left + 1 , right ) if right left : dfs ( currentStr + ) , left , right + 1 ) dfs ( , 0 , 0 ) return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/021-030/#023","text":"\u5408\u5e76\u591a\u4e2a\u6392\u5e8f\u597d\u7684\u94fe\u8868 \u60f3\u6cd5 \u5148\u6765\u4e2a\u66b4\u529b\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def mergeKLists ( self , lists ): :type lists: List[ListNode] :rtype: ListNode def haveSth ( lists ): for i in lists : if i != None : return True return False head = ListNode ( HEAD ) p = head pLists = [ listnode for listnode in lists ] while haveSth ( pLists ): currentMin = ListNode ( float ( inf )) currentMin_index = 0 for i in range ( len ( pLists )): if pLists [ i ] is not None : if pLists [ i ] . val currentMin . val : currentMin = pLists [ i ] currentMin_index = i # break p . next = currentMin p = p . next if pLists [ currentMin_index ]: pLists [ currentMin_index ] = pLists [ currentMin_index ] . next return head . next \u8be5\u7b97\u6cd5\u7528\u4e869000\u591ams\uff0c\u90a3\u4e48\u9700\u8981\u629b\u5f03\u6216\u8005\u4f18\u5316 \u5176\u5b9e\u53ea\u9700\u8981\u53d6\u4e2a\u6700\u5c0f\u503c\uff0c\u6240\u4ee5\uff0c\u5c0f\u6839\u5806\uff1f","title":"023"},{"location":"LeetCode/vol 0/021-030/#_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import heapq class Solution : def mergeKLists ( self , lists ): :type lists: List[ListNode] :rtype: ListNode heap = [] for l in lists : if l != None : heap . append (( l . val , l )) heapq . heapify ( heap ) dummy = ListNode ( 0 ) cur = dummy while heap : _ , h = heapq . heappop ( heap ) cur . next = h cur = cur . next if h . next : heapq . heappush ( heap , ( h . next . val , h . next )) return dummy . next \u4f46\u662f\u7528\u4e86import\uff0c\u6240\u4ee5\u9700\u8981\u81ea\u5df1\u5199\u4e2a\u5c0f\u6839\u5806\uff0c\u6216\u662f\u81ea\u5df1\u8bfbheapq","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/021-030/#024","text":"\u4ea4\u6362\u94fe\u8868\u7684\u76f8\u90bb\u7684\u4e24\u4e2a\u8282\u70b9 1 Given 1- 2- 3- 4, you should return the list as 2- 1- 4- 3. \u76f4\u63a5\u66b4\u529b\u4e86","title":"024"},{"location":"LeetCode/vol 0/021-030/#_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def swapPairs ( self , head ): :type head: ListNode :rtype: ListNode HEAD = ListNode ( HEAD ) HEAD . next = head p = HEAD while p != None : left = p . next if p . next else False right = p . next . next if p . next else False if left and right : left . next = right . next if right . next else None right . next = left p . next = right p = p . next . next else : break return HEAD . next 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def swapPairs ( self , head ): :type head: ListNode :rtype: ListNode if not head : return None newHead = head . next if head . next else head curr = head prev = None while curr and curr . next : temp = curr . next curr . next = curr . next . next temp . next = curr if prev : prev . next = temp prev = curr curr = curr . next return newHead","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/021-030/#025","text":"024\u662f\u4ea4\u6362\u4e24\u4e2a\u76f8\u90bb\u7684\u8282\u70b9\uff0c025\u662f\u7ffb\u8f6c\u8fde\u7eed\u7684n\u4e2a\u8282\u70b9 1 2 3 4 Given this linked list: 1- 2- 3- 4- 5 For k = 2, you should return: 2- 1- 4- 3- 5 For k = 3, you should return: 3- 2- 1- 4- 5 \u60f3\u6cd5 \u7528n\u6765\u63a7\u5236\u5faa\u73af\u6df1\u5ea6 \u5b9e\u73b0\u94fe\u8868\u7684\u7ffb\u8f6c\uff1f \u5efa\u7acb\u4e00\u4e2a\u5faa\u73af\uff0c\u540e\u79fb\u4f4dn\u4e2a\u8282\u70b9\uff0c\u5982\u679c\u5b58\u5728\u9700\u8981\u53cd\u8f6c\uff0c\u5e76\u8bb0\u5f55\u8282\u70b9\u4f4d\u7f6e \u4e00\u5f00\u59cb\u5199\u7684\u662f\u5de6\u95ed\u53f3\u5f00\u7684\uff0c\u5982\u4e0b\uff0c\u5f53head\u4e3a0\uff0cend\u4e3a2\u65f6\uff0c\u53cd\u8f6c\u8282\u70b90\u548c1 1 2 0 - 1 - 2 h e \u4f46\u662f\u51fa\u9519\u4e86\uff0c\u6ca1\u8003\u8651\u597d\u3002\u5904\u4e8e\u4e0b\u9762\u60c5\u51b5\u65f6\uff0c\u4e00\u5f00\u59cb\u7684\u7b97\u6cd5\u5c31\u76f4\u63a5\u8df3\u51fa\u5faa\u73af\u4e86\uff0c\u4f46\u662f\u8fd8\u662f\u9700\u8981\u53cd\u8f6c\u7684 1 2 0 - 1 - None h e \u6240\u4ee5\u9700\u8981\u91cd\u65b0\u5199\u4e2a\uff0c\u6216\u8005\u662f\u6211\u7684\u7b97\u6cd5\u51fa\u9519\u4e86 \u6700\u540e\u8fd8\u662f\u7b97\u6cd5\u51fa\u9519\u4e86","title":"025"},{"location":"LeetCode/vol 0/021-030/#_5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def reverse ( self , headNode , endNode ): prev = endNode p = headNode while p != endNode : tmp = p . next p . next = prev prev = p p = tmp return prev def reverseKGroup ( self , head , k ): :type head: ListNode :type k: int :rtype: ListNode p = head for i in range ( k ): if not p : return head p = p . next newHead = reverse ( head , p ) head . next = self . reverseKGroup ( p , k ) return newHead","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/021-030/#_6","text":"Todo \u6539\u9519 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution : def reverse ( self , headNode , endNode ): TMPHEAD = ListNode ( HEAD ) TMPHEAD . next = endNode p = headNode while p != endNode : currentNode = p p = p . next currentNode . next = TMPHEAD . next TMPHEAD . next = currentNode return TMPHEAD . next def getKthNode ( self , head , k ): p = head for _ in range ( k ): p = p . next if p is None : break return p def reverseKGroup ( self , head , k ): :type head: ListNode :type k: int :rtype: ListNode if not head or head . val == None : return HEAD = ListNode ( HEAD ) HEAD . next = head link = HEAD p = head endNode = self . getKthNode ( p , k ) while p and endNode : headNode = self . reverse ( p , endNode ) p = p . next endNode = self . getKthNode ( p , k ) link . next = headNode link = self . getKthNode ( link , k ) return HEAD . next \u4ee3\u7801\u81c3\u80bf\uff0c\u6839\u636e\u4e4b\u524d\u7684\u53d8\u5316\u6539\u52a8\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def reverse ( self , headNode , endNode ): TMPHEAD = ListNode ( HEAD ) TMPHEAD . next = endNode p = headNode while p != endNode : currentNode = p p = p . next currentNode . next = TMPHEAD . next TMPHEAD . next = currentNode return TMPHEAD . next def reverseKGroup ( self , head , k ): :type head: ListNode :type k: int :rtype: ListNode p = head for i in range ( k ): if p is None : return head p = p . next newHead = self . reverse ( head , p ) head . next = self . reverseKGroup ( p , k ) return newHead \u603b\u7ed3 \u94fe\u8868\u53cd\u8f6c\u8fd8\u662f\u4e0d\u6e05\u6670\uff0c\u867d\u7136\u601d\u8def\u4e00\u6837\u4f46\u8fd8\u662f\u82b1\u4e86\u70b9\u65f6\u95f4\u91cd\u65b0\u7406\u89e3 \u5fd8\u8bb0\u4f7f\u7528\u9012\u5f52","title":"\u9519\u8bef\u4ee3\u7801"},{"location":"LeetCode/vol 0/021-030/#026","text":"\u7ed9\u5b9a\u4e00\u4e2a**\u6392\u597d\u5e8f**\u7684\u6570\u7ec4\uff0c\u5220\u9664\u91cd\u590d\u9879\uff0c\u7ed9\u51fa\u5220\u9664\u91cd\u590d\u9879\u540e\u7684\u957f\u5ea6 \u8981\u6c42\uff0c\u989d\u5916\u7684O(1)\u5185\u5b58 \u5751 \u4e3a\u4ec0\u4e48\u8fd4\u56de\u503c\u662f\u4e00\u4e2a\u6574\u6570\u4f46\u4f60\u7684\u7b54\u6848\u662f\u4e00\u4e2a\u6570\u7ec4\uff1f \u8bf7\u6ce8\u610f\uff0c\u8f93\u5165\u6570\u7ec4\u662f\u901a\u8fc7\u5f15\u7528\u4f20\u5165\u7684\uff0c\u8fd9\u610f\u5473\u7740\u8c03\u7528\u8005\u4e5f\u53ef\u4ee5\u77e5\u9053\u5bf9\u8f93\u5165\u6570\u7ec4\u7684\u4fee\u6539\u3002 \u4f7f\u7528\u8fd4\u56de\u7684\u957f\u5ea6\uff0c\u8fd9\u56de\u6253\u5370\u51fa\u7b2c\u4e00\u4e2a\u7b2ci\u5927\u7684\u503c \u4e5f\u5c31\u662f\u8bf4\uff0c\u4e0d\u662f\u8fd4\u56de\u4e00\u4e2a\u6570\uff0c\u662f\u5bf9\u8fd9\u4e2a\u6570\u7ec4\u8fdb\u884c\u64cd\u4f5c\uff0c\u540c\u65f6\uff0c\u4e0d\u80fd\u4f7f\u7528\u4e00\u4e2a\u989d\u5916\u6570\u7ec4\u6765\u653e\u7f6e\u6570 \u60f3\u6cd5 \u66b4\u529b\u904d\u5386\u8bd5\u8bd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def removeDuplicates ( self , nums ): :type nums: List[int] :rtype: int if len ( nums ) = 1 : return len ( nums ) i = 1 while i len ( nums ): if nums [ i ] == nums [ i - 1 ]: del ( nums [ i ]) else : i += 1 return len ( nums ) \u8fd9\u91cc\u7528\u4e86python\u672c\u8eab\u7684\u51fd\u6570 \u90a3\u4e48\u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5206\u914d\u597d\u7684index\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def removeDuplicates ( self , nums ): :type nums: List[int] :rtype: int if len ( nums ) = 1 : return len ( nums ) index = 1 for i in range ( 1 , len ( nums )): if nums [ i ] nums [ i - 1 ]: nums [ index ] = nums [ i ] index += 1 # del(nums[index:]) return index","title":"026"},{"location":"LeetCode/vol 0/021-030/#027","text":"\u7ed9\u5b9a\u4ee5\u4e2a\u6570\u7ec4nums\u548c\u6570\u5b57val\uff0c\u5c06nums\u5185\u7684\u6240\u6709\u503c\u4e3aval\u7684\u5b9e\u4f8b\u5220\u9664\u6389 \u8981\u6c42\u4e0e026\u7684\u4e00\u6837 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution ( object ): def removeElement ( self , nums , val ): :type nums: List[int] :type val: int :rtype: int # start, end = 0, len(nums) - 1 # while start = end: # if nums[start] == val: # nums[start], nums[end], end = nums[end], nums[start], end - 1 # else: # start += 1 # return start begin = 0 for i in range ( len ( nums )): if nums [ i ] != val : nums [ begin ] = nums [ i ] begin += 1 return begin","title":"027"},{"location":"LeetCode/vol 0/021-030/#028","text":"\u5b9e\u73b0\u51fd\u6570\u6765\u5f97\u5230\u5b50\u5b57\u7b26\u4e32\u5728\u5b57\u7b26\u4e32\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e 1 2 3 4 5 Input: haystack = hello , needle = ll Output: 2 Input: haystack = aaaaa , needle = bba Output: -1 \u60f3\u6cd5 \u6211\u600e\u4e48\u611f\u89c9\u548c026\uff0c027\u7684\u9898\u76ee\u5dee\u4e0d\u591a \u4ec0\u4e48\u9898\u5148\u66b4\u529b\u8bd5\u8bd5 \u4e00\u5f00\u59cb\u7684\u66b4\u529b\u601d\u8def\u51fa\u9519\u4e86\uff0c\u5f53\u78b0\u5230\u4e0b\u9762\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u65f6\u5019\u5c31\u51fa\u9519\u4e86 \u4e00\u5f00\u59cb\u7684\u66b4\u529b\u601d\u8def\u662f\u5728haystack\u627eneedle[0]\u7684\u5b57\u7b26\uff0c\u7136\u540e\u9010\u4e2a\u68c0\u67e5\uff0c\u4f46\u662f\u6ca1\u6709\u8003\u8651\u7c7b\u4f3c\u4e0b\u9762\u53ef\u80fd\u6709\u516c\u5171\u5f00\u5934\u5b57\u7b26\u4e32\u7684\u60c5\u51b5 1 2 mississippi issipi \u90a3\u4e48\u52bf\u5fc5\u8981\u6362\u4e2a\u66b4\u529b\u601d\u8def\uff0c\u6bd4\u5982\u66f4\u539f\u59cb\u7684\u65b9\u5f0f\uff0c\u4f46\u662f\u8fd9\u6837\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u592a\u9ad8\u4e86 \u90a3\u4e48\u80fd\u5426\u4e0aDP\u5462\uff1f \u9700\u8981\u4f7f\u7528\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4dp[i][j]\uff1f\u8868\u793ahaystack[i]\u4e2dneedle[j]\u7684\u51fa\u73b0\u7684\u4f4d\u7f6e\uff1f \u90a3\u4e48\u5982\u4f55\u8fed\u4ee3\u5462\uff0c\u521d\u59cb\u72b6\u6001\uff1f","title":"028"},{"location":"LeetCode/vol 0/021-030/#029","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6574\u6570\u9664\u6570\u4e0e\u4f59\u6570\uff0c\u8fdb\u884c\u9664\u6cd5\u800c\u4e0d\u4f7f\u7528 / , * , % \u901a\u8fc7\u79fb\u4f4d\u6765\u505a\uff1f","title":"029"},{"location":"LeetCode/vol 0/021-030/#030","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5728\u8fd9\u5b57\u7b26\u4e32\u4e2d\u67e5\u627e \u4e00\u4e2a\u7531\u76f8\u540c\u957f\u5ea6\u5b57\u7b26\u4e32\u6784\u6210\u7684\u5217\u8868 \u7684\u6240\u6709\u5bf9\u5e94\u6210\u5458\u7684\u5728\u6bcd\u5b57\u7b26\u4e32\u7684\u7d22\u5f15","title":"030"},{"location":"LeetCode/vol 0/031-040/","text":"031 \u5b9e\u73b0\u4e00\u4e2a\u6c42\u89e3\u6570\u7ec4\u4e0b\u4e00\u4e2a\u5168\u6392\u5217\u7684\u65b9\u6cd5\uff0c\u5982\u679c\u6ca1\u6709\uff0c\u5c31\u5c3d\u53ef\u80fd\u5347\u5e8f\u6392\u5e8f \u4f7f\u7528\u6052\u5b9a\u7684\u989d\u5916\u5185\u5b58 1 2 3 1 , 2 , 3 \u2192 1 , 3 , 2 3 , 2 , 1 \u2192 1 , 2 , 3 1 , 1 , 5 \u2192 1 , 5 , 1 \u60f3\u6cd5 \u56de\u6eaf\uff1f \u9012\u5f52\uff1f \u770b\u4e86\u4e0b\u5176\u4ed6\u89e3\u6cd5\uff0c\u53d1\u73b0\u4f7f\u7528\u4e86\u662f\u5426\u9012\u589e\uff0c\u901a\u8fc7\u662f\u5426\u9012\u589e\u6765\u5224\u5b9a\u662f\u5426\u662f\u5168\u6392\u5217 035 \u7ed9\u5b9a\u4e00\u4e2a\u6392\u5e8f\u6570\u7ec4nums\u548c\u4e00\u4e2a\u6570val\uff0c\u5982\u679cval\u5728nums\u91cc\uff0c\u8fd4\u56de\u7d22\u5f15\uff1b\u5426\u5219\uff0c\u8fd4\u56de\u5e94\u8be5\u63d2\u5165\u7684\u4f4d\u7f6e\u7684\u7d22\u5f15 \u4e8c\u5206\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def searchInsert ( self , nums , target ): :type nums: List[int] :type target: int :rtype: int left = 0 right = len ( nums ) - 1 while left right : middle = ( right + left ) // 2 # middle = left + (right - left) // 2 if nums [ middle ] == target : return middle elif nums [ middle ] target : left = middle + 1 else : right = middle - 1 if target = nums [ left ]: return left else : return right + 1 036 \u5224\u5b9a\u4e00\u4e2a9*9\u7684\u6570\u72ec\u677f\u662f\u5426\u6709\u6548 \u6bcf\u6a2a\uff0c\u6bcf\u5217\uff0c\u6bcf3*3\u7684\u683c\u5b50\u5185\u90fd\u67091-9\u4e14\u4e0d\u91cd\u590d \u60f3\u6cd5 \u96be\u9053\u8981\u66b4\u529b\u904d\u5386\uff1f \u4e0d\u8fc7\u8fd9\u662f\u4e2d\u7b49\u9898\u3002\u3002\u3002\u3002emmmmm \u5bf9\u4e8e\u683c\u5b50\u6709 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 0 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2 1 0,3 0,4 0,5 1,3 1,4 1,5 2,3 2,4 2,5 2 0,6 0,7 0,8 1,6 1,7 1,8 2,6 2,7 2,8 3 3,0 3,1 3,2 4,0 4,1 4,2 5,0 5,1 5,2 \u6cd5\u4e00 \u66b4\u529b\u904d\u5386 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution : def isValidSudoku ( self , board ): :type board: List[List[str]] :rtype: bool for i in range ( 9 ): newList = [] for j in range ( 9 ): if board [ i ][ j ] != . : if board [ i ][ j ] in newList : return False else : newList . append ( board [ i ][ j ]) for j in range ( 9 ): newList = [] for i in range ( 9 ): if board [ i ][ j ] != . : if board [ i ][ j ] in newList : return False else : newList . append ( board [ i ][ j ]) for i in range ( 0 , 9 , 3 ): for j in range ( 0 , 9 , 3 ): newList = [] for newI in range ( 3 ): for newJ in range ( 3 ): if board [ i + newI ][ j + newJ ] != . : if board [ i + newI ][ j + newJ ] in newList : return False else : newList . append ( board [ i + newI ][ j + newJ ]) return True print ( Solution () . isValidSudoku ([ [ 5 , 3 , . , . , 7 , . , . , . , . ], [ 6 , . , . , 1 , 9 , 5 , . , . , . ], [ . , 9 , 8 , . , . , . , . , 6 , . ], [ 8 , . , . , . , 6 , . , . , . , 3 ], [ 4 , . , . , 8 , . , 3 , . , . , 1 ], [ 7 , . , . , . , 2 , . , . , . , 6 ], [ . , 6 , . , . , . , . , 2 , 8 , . ], [ . , . , . , 4 , 1 , 9 , . , . , 5 ], [ . , . , . , . , 8 , . , . , 7 , 9 ] ])) \u6cd5\u4e8c \u4ee3\u7801\u4f18\u96c5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def isValidSudoku ( self , board ): :type board: List[List[str]] :rtype: bool seen = set () for i in range ( 0 , 9 ): for j in range ( 0 , 9 ): elem = board [ i ][ j ] if ( elem != . ): if (( i , elem ) in seen or ( elem , j ) in seen or ( i // 3 , j // 3 , elem ) in seen ): return False seen . add (( i , elem )) seen . add (( elem , j )) seen . add (( i // 3 , j // 3 , elem )) return True 037 \u6570\u72ec\u6c42\u89e3\u5668 \u60f3\u6cd5 \u66b4\u529b DP \u56de\u6eaf \u9996\u5148\u662f\u66b4\u529b \u73b0\u7528python\u672c\u8eab\u7684\u51fd\u6570\u6765\u66b4\u529b\u4e00\u4e0b \u5988\u7684\u66b4\u529b\u66b4\u529b\u5c31\u6210\u56de\u6eaf\u4e86\u3002\u3002\u3002 \u6839\u636e\u53c2\u8003\u8d44\u6599\uff0c\u8fd8\u662f\u56de\u6eaf\u6cd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution : def solveSudoku ( self , board ): :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. rows = [ set () for i in range ( 9 )] cols = [ set () for i in range ( 9 )] boxes = [ set () for i in range ( 9 )] empty = set () for i in range ( 9 ): for j in range ( 9 ): if board [ i ][ j ] == . : empty . add (( i , j )) continue n = board [ i ][ j ] #if n in rows[i] or n in cols[j] or n in boxes[(i//3)*3 + j//3] # return False rows [ i ] . add ( n ) cols [ j ] . add ( n ) boxes [( i // 3 ) * 3 + j // 3 ] . add ( n ) num = set ( 123456789 ) rows = [ num - row for row in rows ] cols = [ num - col for col in cols ] boxes = [ num - box for box in boxes ] result = self . DFS ( board , empty , rows , cols , boxes ) def DFS ( self , board , empty , rows , cols , boxes ): if len ( empty ) == 0 : return True maxpossible = 9 for r , c in empty : possible = rows [ r ] cols [ c ] boxes [( r // 3 ) * 3 + c // 3 ] if len ( possible ) maxpossible : maxpossible = len ( possible ) i , j = r , c if maxpossible == 0 : return False possible = rows [ i ] cols [ j ] boxes [( i // 3 ) * 3 + j // 3 ] empty . remove (( i , j )) for opt in possible : rows [ i ] . discard ( opt ) cols [ j ] . discard ( opt ) boxes [( i // 3 ) * 3 + j // 3 ] . discard ( opt ) board [ i ][ j ] = opt if self . DFS ( board , empty , rows , cols , boxes ): return True board [ i ][ j ] = . rows [ i ] . add ( opt ) cols [ j ] . add ( opt ) boxes [( i // 3 ) * 3 + j // 3 ] . add ( opt ) empty . add (( i , j )) return False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution : def solveSudoku ( self , board ): self . board = board self . solve () def solve ( self ): # \u4e3b\u9012\u5f52\u51fd\u6570 row , col = self . findUnassigned () # \u83b7\u53d6\u4e00\u4e2a\u672a\u88ab\u5206\u914d\u7684\u65b9\u683c if row == - 1 and col == - 1 : # \u6ca1\u6709\u627e\u5230\uff0c\u8bf4\u660e\u5df2\u7ecf\u586b\u597d return True for num in [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]: if self . isSafe ( row , col , num ): # \u5faa\u73af\u586b\u5165\u6570\u5b57\uff0c\u5e76\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u8981\u6c42 self . board [ row ][ col ] = num if self . solve (): # \u9012\u5f52\u8fdb\u5165\u4e0b\u4e00\u4e2a\u65b9\u683c return True self . board [ row ][ col ] = . # \u540e\u7eed\u4e0d\u6ee1\u8db3\uff0c\u90a3\u4e48\u73b0\u5728\u8981\u56de\u590d\u5f53\u524d\u73af\u5883\uff0c\u5e76\u8fdb\u884c\u4e0b\u4e00\u4e2a\u6570\u5b57\u8bd5\u63a2 return False def findUnassigned ( self ): # \u4f9d\u6b21\u67e5\u627e\u672a\u88ab\u5206\u914d\u7684\u65b9\u683c for row in range ( 9 ): for col in range ( 9 ): if self . board [ row ][ col ] == . : return row , col return - 1 , - 1 def isSafe ( self , row , col , ch ): # \u5224\u65ad\u662f\u5426\u5f53\u524d\u65b9\u683c\u586b\u5165\u7684\u6570\u5b57\u662f\u5426\u6ee1\u8db3\u8981\u6c42 boxrow = row - row % 3 # \u786e\u5b9a3x3\u5c0f\u5bab\u683c\u7684\u5f00\u59cb\u5750\u6807\uff0c\u5c31\u662f3x3\u5c0f\u5bab\u683c\u7b2c\u4e00\u4e2a\u65b9\u683c\u7d22\u5f15 boxcol = col - col % 3 if self . checkrow ( row , ch ) and self . checkcol ( col , ch ) and self . checksquare ( boxrow , boxcol , ch ): return True return False def checkrow ( self , row , ch ): # \u68c0\u67e5\u4e00\u884c\u662f\u5426\u7b26\u5408\u6761\u4ef6 for col in range ( 9 ): if self . board [ row ][ col ] == ch : return False return True def checkcol ( self , col , ch ): # \u68c0\u67e5\u4e00\u5217\u662f\u5426\u7b26\u5408\u6761\u4ef6 for row in range ( 9 ): if self . board [ row ][ col ] == ch : return False return True def checksquare ( self , row , col , ch ): # \u68c0\u67e53x3\u5c0f\u5bab\u683c\u662f\u5426\u7b26\u5408\u6761\u4ef6 for r in range ( row , row + 3 ): for c in range ( col , col + 3 ): if self . board [ r ][ c ] == ch : return False return True 038 \u6570\u6570\u4e0e\u8bf4\uff0c\u9996\u5148\u7ed9\u51fa5\u4e2a\u6570\uff08hash\u5e8f\u5217\uff1f\u8fd8\u662f\u627e\u89c4\u5f8b\uff1f\uff09\uff0c\u7136\u540e\u7ed9\u5b9a\u4e00\u4e2a1\u523030\u7684\u6570n\uff0c\u8f93\u51fa\u5bf9\u5e94\u7684\u5e8f\u5217 1 2 3 4 5 1. 1 2. 11 # \u4e00\u4e2a1 3. 21 # \u4e24\u4e2a1 4. 1211 # \u4e00\u4e2a2\u4e24\u4e2a1 5. 111221 # \u4e00\u4e2a1\u4e00\u4e2a2\u4e24\u4e2a1 \u6839\u636e\u53c2\u8003\u8d44\u6599\u7684\u8bf4\u660e\uff0c\u5f97\u5230\u9898\u610f \u60f3\u6cd5 \u90a3\u4e48\u5c31\u662f\u9700\u8981\u9012\u5f52\u4e86\uff1f \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def countAndSay ( self , n ): :type n: int :rtype: str if n == 1 : return 1 # elif n == 2: # return 11 else : # \u589e\u52a0\u672b\u5c3e\u6807\u8bb0\u7b26\u53f7\uff0c\u6807\u8bc6\u672b\u5c3e lastString = self . countAndSay ( n - 1 ) + * res = count = 1 for i in range ( len ( lastString ) - 1 ): if lastString [ i ] == lastString [ i + 1 ]: count += 1 else : res = res + str ( count ) + lastString [ i ] count = 1 return res 039 Todo \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4nums\u548c\u4e00\u4e2a\u6570target\uff0c\u4ece\u6570\u7ec4\u4e2d\u51d1\u6570\u5b57\u4f7f\u5f97\u548c\u4e3atarget\uff0c\u5176\u4e2d\uff0cnums\u7684\u6570\u5b57\u53ef\u4ee5\u91cd\u590d 1 2 3 4 5 6 Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] \u60f3\u6cd5 \u4f7f\u7528dic\u6765\u8bb0\u5f55\uff1fdic[i]=set(list1,list2)=== dic[target]=set(list1,list2) \u8fd9\u79cd\u60f3\u6cd5\u9519\u8bef\uff0cset\u4e0d\u80fd\u4ee5list\u521d\u59cb\u5316\uff0clist\u4e0d\u53efhash \u90a3\u4e48\u53ea\u80fd\u8fd9\u6837\u4f7f\u7528:dic[i]=[sorted(list1),sorted(list2),...] \u5199\u662f\u53ef\u4ee5\uff0c\u4f46\u662f\u4f18\u5316\u4f59\u5730\u7279\u522b\u5927 \u90a3\u4e48\u8fd9\u6837\u904d\u5386\u7684\u601d\u60f3\u662f\u4e0d\u884c\u7684 \u6240\u4ee5\uff0c\u4f7f\u7528\u56de\u6eaf\uff0c\u6216\u8005\u9012\u5f52 \u5bf9\u4e8e\u9012\u5f52\u6765\u8bf4\uff0c\u7ec8\u6b62\u60c5\u51b5\u662f\uff0cdiff=target-num=0\uff1b\u6f14\u8fdb\u8fc7\u7a0b\u662f\uff0c\u4e0d\u65ad\u5bf9diff\u67e5\u627e\uff0c\u627e\u5230diff\u6240\u5c5e\u7684\u7b54\u6848\u540e\u5c06\u5176append \u8349\u7a3f \u5931\u8d25\uff0c\u4ee5\u540e\u518d\u8bf4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def combinationSum ( self , candidates , target ): result = [] candidates = sorted ( candidates ) def combinationSum_helper ( diff , result_tmp ): if diff == 0 : result . append ( result_tmp ) for candidate in candidates : if candidate diff : break if candidates result_tmp [ - 1 ]: continue else : combinationSum_helper ( diff - candidate , result_tmp + [ candidates ]) combinationSum_helper ( target ,[]) return result \u5176\u4ed6 \u4f7f\u7528\u6df1\u5ea6\u641c\u7d22 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def combinationSum ( self , candidates , target ): result = [] candidates = sorted ( candidates ) def dfs ( remain , stack ): if remain == 0 : result . append ( stack ) return for item in candidates : if item remain : break # todo make the line clean if stack and item stack [ - 1 ]: continue else : dfs ( remain - item , stack + [ item ]) dfs ( target , []) return result","title":"031 040"},{"location":"LeetCode/vol 0/031-040/#031","text":"\u5b9e\u73b0\u4e00\u4e2a\u6c42\u89e3\u6570\u7ec4\u4e0b\u4e00\u4e2a\u5168\u6392\u5217\u7684\u65b9\u6cd5\uff0c\u5982\u679c\u6ca1\u6709\uff0c\u5c31\u5c3d\u53ef\u80fd\u5347\u5e8f\u6392\u5e8f \u4f7f\u7528\u6052\u5b9a\u7684\u989d\u5916\u5185\u5b58 1 2 3 1 , 2 , 3 \u2192 1 , 3 , 2 3 , 2 , 1 \u2192 1 , 2 , 3 1 , 1 , 5 \u2192 1 , 5 , 1 \u60f3\u6cd5 \u56de\u6eaf\uff1f \u9012\u5f52\uff1f \u770b\u4e86\u4e0b\u5176\u4ed6\u89e3\u6cd5\uff0c\u53d1\u73b0\u4f7f\u7528\u4e86\u662f\u5426\u9012\u589e\uff0c\u901a\u8fc7\u662f\u5426\u9012\u589e\u6765\u5224\u5b9a\u662f\u5426\u662f\u5168\u6392\u5217","title":"031"},{"location":"LeetCode/vol 0/031-040/#035","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6392\u5e8f\u6570\u7ec4nums\u548c\u4e00\u4e2a\u6570val\uff0c\u5982\u679cval\u5728nums\u91cc\uff0c\u8fd4\u56de\u7d22\u5f15\uff1b\u5426\u5219\uff0c\u8fd4\u56de\u5e94\u8be5\u63d2\u5165\u7684\u4f4d\u7f6e\u7684\u7d22\u5f15 \u4e8c\u5206\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def searchInsert ( self , nums , target ): :type nums: List[int] :type target: int :rtype: int left = 0 right = len ( nums ) - 1 while left right : middle = ( right + left ) // 2 # middle = left + (right - left) // 2 if nums [ middle ] == target : return middle elif nums [ middle ] target : left = middle + 1 else : right = middle - 1 if target = nums [ left ]: return left else : return right + 1","title":"035"},{"location":"LeetCode/vol 0/031-040/#036","text":"\u5224\u5b9a\u4e00\u4e2a9*9\u7684\u6570\u72ec\u677f\u662f\u5426\u6709\u6548 \u6bcf\u6a2a\uff0c\u6bcf\u5217\uff0c\u6bcf3*3\u7684\u683c\u5b50\u5185\u90fd\u67091-9\u4e14\u4e0d\u91cd\u590d \u60f3\u6cd5 \u96be\u9053\u8981\u66b4\u529b\u904d\u5386\uff1f \u4e0d\u8fc7\u8fd9\u662f\u4e2d\u7b49\u9898\u3002\u3002\u3002\u3002emmmmm \u5bf9\u4e8e\u683c\u5b50\u6709 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 0 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2 1 0,3 0,4 0,5 1,3 1,4 1,5 2,3 2,4 2,5 2 0,6 0,7 0,8 1,6 1,7 1,8 2,6 2,7 2,8 3 3,0 3,1 3,2 4,0 4,1 4,2 5,0 5,1 5,2","title":"036"},{"location":"LeetCode/vol 0/031-040/#_1","text":"\u66b4\u529b\u904d\u5386 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution : def isValidSudoku ( self , board ): :type board: List[List[str]] :rtype: bool for i in range ( 9 ): newList = [] for j in range ( 9 ): if board [ i ][ j ] != . : if board [ i ][ j ] in newList : return False else : newList . append ( board [ i ][ j ]) for j in range ( 9 ): newList = [] for i in range ( 9 ): if board [ i ][ j ] != . : if board [ i ][ j ] in newList : return False else : newList . append ( board [ i ][ j ]) for i in range ( 0 , 9 , 3 ): for j in range ( 0 , 9 , 3 ): newList = [] for newI in range ( 3 ): for newJ in range ( 3 ): if board [ i + newI ][ j + newJ ] != . : if board [ i + newI ][ j + newJ ] in newList : return False else : newList . append ( board [ i + newI ][ j + newJ ]) return True print ( Solution () . isValidSudoku ([ [ 5 , 3 , . , . , 7 , . , . , . , . ], [ 6 , . , . , 1 , 9 , 5 , . , . , . ], [ . , 9 , 8 , . , . , . , . , 6 , . ], [ 8 , . , . , . , 6 , . , . , . , 3 ], [ 4 , . , . , 8 , . , 3 , . , . , 1 ], [ 7 , . , . , . , 2 , . , . , . , 6 ], [ . , 6 , . , . , . , . , 2 , 8 , . ], [ . , . , . , 4 , 1 , 9 , . , . , 5 ], [ . , . , . , . , 8 , . , . , 7 , 9 ] ]))","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/031-040/#_2","text":"\u4ee3\u7801\u4f18\u96c5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def isValidSudoku ( self , board ): :type board: List[List[str]] :rtype: bool seen = set () for i in range ( 0 , 9 ): for j in range ( 0 , 9 ): elem = board [ i ][ j ] if ( elem != . ): if (( i , elem ) in seen or ( elem , j ) in seen or ( i // 3 , j // 3 , elem ) in seen ): return False seen . add (( i , elem )) seen . add (( elem , j )) seen . add (( i // 3 , j // 3 , elem )) return True","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 0/031-040/#037","text":"\u6570\u72ec\u6c42\u89e3\u5668 \u60f3\u6cd5 \u66b4\u529b DP \u56de\u6eaf \u9996\u5148\u662f\u66b4\u529b \u73b0\u7528python\u672c\u8eab\u7684\u51fd\u6570\u6765\u66b4\u529b\u4e00\u4e0b \u5988\u7684\u66b4\u529b\u66b4\u529b\u5c31\u6210\u56de\u6eaf\u4e86\u3002\u3002\u3002 \u6839\u636e\u53c2\u8003\u8d44\u6599\uff0c\u8fd8\u662f\u56de\u6eaf\u6cd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution : def solveSudoku ( self , board ): :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. rows = [ set () for i in range ( 9 )] cols = [ set () for i in range ( 9 )] boxes = [ set () for i in range ( 9 )] empty = set () for i in range ( 9 ): for j in range ( 9 ): if board [ i ][ j ] == . : empty . add (( i , j )) continue n = board [ i ][ j ] #if n in rows[i] or n in cols[j] or n in boxes[(i//3)*3 + j//3] # return False rows [ i ] . add ( n ) cols [ j ] . add ( n ) boxes [( i // 3 ) * 3 + j // 3 ] . add ( n ) num = set ( 123456789 ) rows = [ num - row for row in rows ] cols = [ num - col for col in cols ] boxes = [ num - box for box in boxes ] result = self . DFS ( board , empty , rows , cols , boxes ) def DFS ( self , board , empty , rows , cols , boxes ): if len ( empty ) == 0 : return True maxpossible = 9 for r , c in empty : possible = rows [ r ] cols [ c ] boxes [( r // 3 ) * 3 + c // 3 ] if len ( possible ) maxpossible : maxpossible = len ( possible ) i , j = r , c if maxpossible == 0 : return False possible = rows [ i ] cols [ j ] boxes [( i // 3 ) * 3 + j // 3 ] empty . remove (( i , j )) for opt in possible : rows [ i ] . discard ( opt ) cols [ j ] . discard ( opt ) boxes [( i // 3 ) * 3 + j // 3 ] . discard ( opt ) board [ i ][ j ] = opt if self . DFS ( board , empty , rows , cols , boxes ): return True board [ i ][ j ] = . rows [ i ] . add ( opt ) cols [ j ] . add ( opt ) boxes [( i // 3 ) * 3 + j // 3 ] . add ( opt ) empty . add (( i , j )) return False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution : def solveSudoku ( self , board ): self . board = board self . solve () def solve ( self ): # \u4e3b\u9012\u5f52\u51fd\u6570 row , col = self . findUnassigned () # \u83b7\u53d6\u4e00\u4e2a\u672a\u88ab\u5206\u914d\u7684\u65b9\u683c if row == - 1 and col == - 1 : # \u6ca1\u6709\u627e\u5230\uff0c\u8bf4\u660e\u5df2\u7ecf\u586b\u597d return True for num in [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]: if self . isSafe ( row , col , num ): # \u5faa\u73af\u586b\u5165\u6570\u5b57\uff0c\u5e76\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u8981\u6c42 self . board [ row ][ col ] = num if self . solve (): # \u9012\u5f52\u8fdb\u5165\u4e0b\u4e00\u4e2a\u65b9\u683c return True self . board [ row ][ col ] = . # \u540e\u7eed\u4e0d\u6ee1\u8db3\uff0c\u90a3\u4e48\u73b0\u5728\u8981\u56de\u590d\u5f53\u524d\u73af\u5883\uff0c\u5e76\u8fdb\u884c\u4e0b\u4e00\u4e2a\u6570\u5b57\u8bd5\u63a2 return False def findUnassigned ( self ): # \u4f9d\u6b21\u67e5\u627e\u672a\u88ab\u5206\u914d\u7684\u65b9\u683c for row in range ( 9 ): for col in range ( 9 ): if self . board [ row ][ col ] == . : return row , col return - 1 , - 1 def isSafe ( self , row , col , ch ): # \u5224\u65ad\u662f\u5426\u5f53\u524d\u65b9\u683c\u586b\u5165\u7684\u6570\u5b57\u662f\u5426\u6ee1\u8db3\u8981\u6c42 boxrow = row - row % 3 # \u786e\u5b9a3x3\u5c0f\u5bab\u683c\u7684\u5f00\u59cb\u5750\u6807\uff0c\u5c31\u662f3x3\u5c0f\u5bab\u683c\u7b2c\u4e00\u4e2a\u65b9\u683c\u7d22\u5f15 boxcol = col - col % 3 if self . checkrow ( row , ch ) and self . checkcol ( col , ch ) and self . checksquare ( boxrow , boxcol , ch ): return True return False def checkrow ( self , row , ch ): # \u68c0\u67e5\u4e00\u884c\u662f\u5426\u7b26\u5408\u6761\u4ef6 for col in range ( 9 ): if self . board [ row ][ col ] == ch : return False return True def checkcol ( self , col , ch ): # \u68c0\u67e5\u4e00\u5217\u662f\u5426\u7b26\u5408\u6761\u4ef6 for row in range ( 9 ): if self . board [ row ][ col ] == ch : return False return True def checksquare ( self , row , col , ch ): # \u68c0\u67e53x3\u5c0f\u5bab\u683c\u662f\u5426\u7b26\u5408\u6761\u4ef6 for r in range ( row , row + 3 ): for c in range ( col , col + 3 ): if self . board [ r ][ c ] == ch : return False return True","title":"037"},{"location":"LeetCode/vol 0/031-040/#038","text":"\u6570\u6570\u4e0e\u8bf4\uff0c\u9996\u5148\u7ed9\u51fa5\u4e2a\u6570\uff08hash\u5e8f\u5217\uff1f\u8fd8\u662f\u627e\u89c4\u5f8b\uff1f\uff09\uff0c\u7136\u540e\u7ed9\u5b9a\u4e00\u4e2a1\u523030\u7684\u6570n\uff0c\u8f93\u51fa\u5bf9\u5e94\u7684\u5e8f\u5217 1 2 3 4 5 1. 1 2. 11 # \u4e00\u4e2a1 3. 21 # \u4e24\u4e2a1 4. 1211 # \u4e00\u4e2a2\u4e24\u4e2a1 5. 111221 # \u4e00\u4e2a1\u4e00\u4e2a2\u4e24\u4e2a1 \u6839\u636e\u53c2\u8003\u8d44\u6599\u7684\u8bf4\u660e\uff0c\u5f97\u5230\u9898\u610f \u60f3\u6cd5 \u90a3\u4e48\u5c31\u662f\u9700\u8981\u9012\u5f52\u4e86\uff1f","title":"038"},{"location":"LeetCode/vol 0/031-040/#_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def countAndSay ( self , n ): :type n: int :rtype: str if n == 1 : return 1 # elif n == 2: # return 11 else : # \u589e\u52a0\u672b\u5c3e\u6807\u8bb0\u7b26\u53f7\uff0c\u6807\u8bc6\u672b\u5c3e lastString = self . countAndSay ( n - 1 ) + * res = count = 1 for i in range ( len ( lastString ) - 1 ): if lastString [ i ] == lastString [ i + 1 ]: count += 1 else : res = res + str ( count ) + lastString [ i ] count = 1 return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/031-040/#039","text":"Todo \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4nums\u548c\u4e00\u4e2a\u6570target\uff0c\u4ece\u6570\u7ec4\u4e2d\u51d1\u6570\u5b57\u4f7f\u5f97\u548c\u4e3atarget\uff0c\u5176\u4e2d\uff0cnums\u7684\u6570\u5b57\u53ef\u4ee5\u91cd\u590d 1 2 3 4 5 6 Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] \u60f3\u6cd5 \u4f7f\u7528dic\u6765\u8bb0\u5f55\uff1fdic[i]=set(list1,list2)=== dic[target]=set(list1,list2) \u8fd9\u79cd\u60f3\u6cd5\u9519\u8bef\uff0cset\u4e0d\u80fd\u4ee5list\u521d\u59cb\u5316\uff0clist\u4e0d\u53efhash \u90a3\u4e48\u53ea\u80fd\u8fd9\u6837\u4f7f\u7528:dic[i]=[sorted(list1),sorted(list2),...] \u5199\u662f\u53ef\u4ee5\uff0c\u4f46\u662f\u4f18\u5316\u4f59\u5730\u7279\u522b\u5927 \u90a3\u4e48\u8fd9\u6837\u904d\u5386\u7684\u601d\u60f3\u662f\u4e0d\u884c\u7684 \u6240\u4ee5\uff0c\u4f7f\u7528\u56de\u6eaf\uff0c\u6216\u8005\u9012\u5f52 \u5bf9\u4e8e\u9012\u5f52\u6765\u8bf4\uff0c\u7ec8\u6b62\u60c5\u51b5\u662f\uff0cdiff=target-num=0\uff1b\u6f14\u8fdb\u8fc7\u7a0b\u662f\uff0c\u4e0d\u65ad\u5bf9diff\u67e5\u627e\uff0c\u627e\u5230diff\u6240\u5c5e\u7684\u7b54\u6848\u540e\u5c06\u5176append","title":"039"},{"location":"LeetCode/vol 0/031-040/#_4","text":"\u5931\u8d25\uff0c\u4ee5\u540e\u518d\u8bf4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def combinationSum ( self , candidates , target ): result = [] candidates = sorted ( candidates ) def combinationSum_helper ( diff , result_tmp ): if diff == 0 : result . append ( result_tmp ) for candidate in candidates : if candidate diff : break if candidates result_tmp [ - 1 ]: continue else : combinationSum_helper ( diff - candidate , result_tmp + [ candidates ]) combinationSum_helper ( target ,[]) return result","title":"\u8349\u7a3f"},{"location":"LeetCode/vol 0/031-040/#_5","text":"\u4f7f\u7528\u6df1\u5ea6\u641c\u7d22 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def combinationSum ( self , candidates , target ): result = [] candidates = sorted ( candidates ) def dfs ( remain , stack ): if remain == 0 : result . append ( stack ) return for item in candidates : if item remain : break # todo make the line clean if stack and item stack [ - 1 ]: continue else : dfs ( remain - item , stack + [ item ]) dfs ( target , []) return result","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 0/051-060/","text":"053 \u627e\u5230\u6700\u5927\u8fde\u7eed\u5b50\u5e8f\u5217\u548c \u60f3\u6cd5 DP? DP[i] \u5b58\u653e\u5f53\u524d\u5f53\u524dindex\u7684\u7eed\u7684\u6700\u5927\u5b50\u5e8f\u5217\u548c DP[i] = (DP[i-1] 0 ? DP[i-1],0) + nums[i] \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxSubArray ( self , nums ): :type nums: List[int] :rtype: int DP = [ 0 for _ in range ( len ( nums ))] DP [ 0 ] = nums [ 0 ] for i in range ( 1 , len ( nums )): DP [ i ] = ( DP [ i - 1 ] if DP [ i - 1 ] 0 else 0 ) + nums [ i ] return max ( DP ) 054 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u8fd4\u56de\u5b83\u7684\u87ba\u65cb\u904d\u5386 \u60f3\u6cd5 \u4f7f\u7528colStart,colEnd,rowStart,rowEnd\u6765\u63a7\u5236\u5faa\u73af\u6df1\u5ea6 \u6cd5\u4e00 \u901a\u8fc7\u66b4\u529b\u7684\u5faa\u73af\u68c0\u67e5\u6765\u63a7\u5236\u8fb9\u754c\u6761\u4ef6 \u867d\u7136\u5feb\uff0c\u4f46\u662f\u5185\u5b58\u6d88\u8017\u633a\u5927\u7684\uff0c\u6307\u51fb\u8d25\u4e869% \u800c\u4e14\u4e5f\u4e0d\u4f18\u96c5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution : def spiralOrder ( self , matrix ): :type matrix: List[List[int]] :rtype: List[int] if len ( matrix ) == 0 : return [] rowStart = 0 rowEnd = len ( matrix ) - 1 colStart = 0 colEnd = len ( matrix [ 0 ]) - 1 res = [] while rowStart = rowEnd and colStart = colEnd : for j in range ( colStart , colEnd + 1 ): res . append ( matrix [ rowStart ][ j ]) rowStart += 1 if not ( rowStart = rowEnd and colStart = colEnd ): break for i in range ( rowStart , rowEnd + 1 ): res . append ( matrix [ i ][ colEnd ]) colEnd -= 1 if not ( rowStart = rowEnd and colStart = colEnd ): break for j in range ( colEnd , colStart - 1 , - 1 ): res . append ( matrix [ rowEnd ][ j ]) rowEnd -= 1 if not ( rowStart = rowEnd and colStart = colEnd ): break for i in range ( rowEnd , rowStart - 1 , - 1 ): res . append ( matrix [ i ][ colStart ]) colStart += 1 if not ( rowStart = rowEnd and colStart = colEnd ): break return res \u6cd5\u4e8c \u6bcf\u6b21\u987a\u65f6\u9488\u8f6c\u6362\u6210\u4e00\u4e2a\u65b0\u7684matrix\uff0c\u7136\u540epop\u4e4b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def spiralOrder ( self , matrix ): :type matrix: List[List[int]] :rtype: List[int] spiral = [] while matrix : spiral += matrix . pop ( 0 ) if not matrix : break new = [] for i in range ( len ( matrix [ 0 ]) - 1 , - 1 , - 1 ): line = [] for j in range ( len ( matrix )): line . append ( matrix [ j ][ i ]) new . append ( line ) matrix = new return spiral 056 \u7ed9\u5b9a\u533a\u95f4\u7684\u96c6\u5408\uff0c\u5408\u5e76\u6240\u6709\u91cd\u590d\u7684\u533a\u95f4 1 2 3 Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. \u66b4\u529b\u5c31\u5b8c\u4e8b\u4e86 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def merge ( self , intervals ): :type intervals: List[Interval] :rtype: List[Interval] res = [] for interval in sorted ( intervals , key = lambda x : x . start ): # \u5982\u679c\u904d\u5386\u7684\u5b9a\u4e49\u57df\u7684start\u6bd4\u8bb0\u5f55\u7684\u5b9a\u4e49\u57df\u7684end\u5c0f # \u5373\u6ee1\u8db3\u91cd\u5408\u7684\u6761\u4ef6 if res and interval . start = res [ - 1 ] . end : res [ - 1 ] . end = max ( res [ - 1 ] . end , interval . end ) else : res . append ( interval ) return res 058 \u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u7684\u957f\u5ea6 \u60f3\u6cd5 \u5148\u7528python\u81ea\u8eab\u7684\u51fd\u6570\u6765\u505a 1 2 3 4 class Solution : def lengthOfLastWord ( self , s : str ) - int : sLists = s . strip () . split ( ) return len ( sLists [ - 1 ]) v \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lengthOfLastWord ( self , s : str ) - int : if len ( s ) == 0 : return 0 index = len ( s ) - 1 while ( s [ index ] == \\n or s [ index ] == ) and index = 0 : index -= 1 res = 0 for i in range ( index , - 1 , - 1 ): if s [ i ] == : break else : res += 1 return res 059 \u9762\u8bd5\u7ecf\u5178\u9898 \u7ed9\u5b9a\u4e00\u4e2an\uff0c\u751f\u6210\u4e00\u4e2an^2\u7684\u87ba\u65cb\u77e9\u9635 \u66b4\u529b\u51fa\u5947\u8ff9 \u8003\u9a8c\u57fa\u672c\u7684\u8fb9\u754c\u95ee\u9898 \u6cd5\u4e00 \u66b4\u529b\u5c31\u5b8c\u4e8b\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def generateMatrix ( self , n ): :type n: int :rtype: List[List[int]] if n == 0 : return [] res = [[ 0 for i in range ( n )] for i in range ( n )] rowStart , colStart = 0 , 0 rowEnd , colEnd = n - 1 , n - 1 num = 1 while rowStart = rowEnd and colStart = colEnd : for j in range ( colStart , colEnd + 1 ): res [ rowStart ][ j ] = num num += 1 rowStart += 1 for i in range ( rowStart , rowEnd + 1 ): res [ i ][ colEnd ] = num num += 1 colEnd -= 1 for j in range ( colEnd , colStart - 1 , - 1 ): res [ rowEnd ][ j ] = num num += 1 rowEnd -= 1 for i in range ( rowEnd , rowStart - 1 , - 1 ): res [ i ][ colStart ] = num num += 1 colStart += 1 return res 060 Todo \u7ed9\u5b9a\u4e24\u4e2a\u6570n\u548ck\uff0c\u6c42\u75311\uff0c2\uff0c\u2026\u2026\uff0cn\u6784\u6210\u7684n\u4e2a\u6570\u7ec4\u6210\u7b2ck\u4e2a\u5168\u6392\u5217 1 2 3 4 5 6 7 8 9 10 By listing and labeling all of the permutations in order, we get the following sequence for n = 3: 123 132 213 231 312 321 Given n and k, return the kth permutation sequence. \u60f3\u6cd5 \u6240\u4ee5\u8fd8\u662f\u9003\u4e0d\u5f00\u5168\u6392\u5217 \u5168\u6392\u5217\u7684\u516c\u5f0f\u4e3a A^m_n=\\frac{n!}{(n-m)!} A^m_n=\\frac{n!}{(n-m)!} \uff0c\u6240\u4ee5 A^n_n=n! A^n_n=n! \u4ee51\u5f00\u5934\u7684\u6392\u5217\u6709(n-1)!\u4e2a \u6839\u636e\u7ed9\u5b9a\u7684k\u786e\u5b9a\u662f\u4ec0\u4e48\u6570\u5b57\u5f00\u5934\uff1f\u9012\u5f52\uff1f","title":"051 060"},{"location":"LeetCode/vol 0/051-060/#053","text":"\u627e\u5230\u6700\u5927\u8fde\u7eed\u5b50\u5e8f\u5217\u548c \u60f3\u6cd5 DP? DP[i] \u5b58\u653e\u5f53\u524d\u5f53\u524dindex\u7684\u7eed\u7684\u6700\u5927\u5b50\u5e8f\u5217\u548c DP[i] = (DP[i-1] 0 ? DP[i-1],0) + nums[i]","title":"053"},{"location":"LeetCode/vol 0/051-060/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxSubArray ( self , nums ): :type nums: List[int] :rtype: int DP = [ 0 for _ in range ( len ( nums ))] DP [ 0 ] = nums [ 0 ] for i in range ( 1 , len ( nums )): DP [ i ] = ( DP [ i - 1 ] if DP [ i - 1 ] 0 else 0 ) + nums [ i ] return max ( DP )","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/051-060/#054","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u8fd4\u56de\u5b83\u7684\u87ba\u65cb\u904d\u5386 \u60f3\u6cd5 \u4f7f\u7528colStart,colEnd,rowStart,rowEnd\u6765\u63a7\u5236\u5faa\u73af\u6df1\u5ea6","title":"054"},{"location":"LeetCode/vol 0/051-060/#_2","text":"\u901a\u8fc7\u66b4\u529b\u7684\u5faa\u73af\u68c0\u67e5\u6765\u63a7\u5236\u8fb9\u754c\u6761\u4ef6 \u867d\u7136\u5feb\uff0c\u4f46\u662f\u5185\u5b58\u6d88\u8017\u633a\u5927\u7684\uff0c\u6307\u51fb\u8d25\u4e869% \u800c\u4e14\u4e5f\u4e0d\u4f18\u96c5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution : def spiralOrder ( self , matrix ): :type matrix: List[List[int]] :rtype: List[int] if len ( matrix ) == 0 : return [] rowStart = 0 rowEnd = len ( matrix ) - 1 colStart = 0 colEnd = len ( matrix [ 0 ]) - 1 res = [] while rowStart = rowEnd and colStart = colEnd : for j in range ( colStart , colEnd + 1 ): res . append ( matrix [ rowStart ][ j ]) rowStart += 1 if not ( rowStart = rowEnd and colStart = colEnd ): break for i in range ( rowStart , rowEnd + 1 ): res . append ( matrix [ i ][ colEnd ]) colEnd -= 1 if not ( rowStart = rowEnd and colStart = colEnd ): break for j in range ( colEnd , colStart - 1 , - 1 ): res . append ( matrix [ rowEnd ][ j ]) rowEnd -= 1 if not ( rowStart = rowEnd and colStart = colEnd ): break for i in range ( rowEnd , rowStart - 1 , - 1 ): res . append ( matrix [ i ][ colStart ]) colStart += 1 if not ( rowStart = rowEnd and colStart = colEnd ): break return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/051-060/#_3","text":"\u6bcf\u6b21\u987a\u65f6\u9488\u8f6c\u6362\u6210\u4e00\u4e2a\u65b0\u7684matrix\uff0c\u7136\u540epop\u4e4b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def spiralOrder ( self , matrix ): :type matrix: List[List[int]] :rtype: List[int] spiral = [] while matrix : spiral += matrix . pop ( 0 ) if not matrix : break new = [] for i in range ( len ( matrix [ 0 ]) - 1 , - 1 , - 1 ): line = [] for j in range ( len ( matrix )): line . append ( matrix [ j ][ i ]) new . append ( line ) matrix = new return spiral","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 0/051-060/#056","text":"\u7ed9\u5b9a\u533a\u95f4\u7684\u96c6\u5408\uff0c\u5408\u5e76\u6240\u6709\u91cd\u590d\u7684\u533a\u95f4 1 2 3 Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. \u66b4\u529b\u5c31\u5b8c\u4e8b\u4e86","title":"056"},{"location":"LeetCode/vol 0/051-060/#_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def merge ( self , intervals ): :type intervals: List[Interval] :rtype: List[Interval] res = [] for interval in sorted ( intervals , key = lambda x : x . start ): # \u5982\u679c\u904d\u5386\u7684\u5b9a\u4e49\u57df\u7684start\u6bd4\u8bb0\u5f55\u7684\u5b9a\u4e49\u57df\u7684end\u5c0f # \u5373\u6ee1\u8db3\u91cd\u5408\u7684\u6761\u4ef6 if res and interval . start = res [ - 1 ] . end : res [ - 1 ] . end = max ( res [ - 1 ] . end , interval . end ) else : res . append ( interval ) return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/051-060/#058","text":"\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u7684\u957f\u5ea6 \u60f3\u6cd5 \u5148\u7528python\u81ea\u8eab\u7684\u51fd\u6570\u6765\u505a 1 2 3 4 class Solution : def lengthOfLastWord ( self , s : str ) - int : sLists = s . strip () . split ( ) return len ( sLists [ - 1 ]) v","title":"058"},{"location":"LeetCode/vol 0/051-060/#_5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lengthOfLastWord ( self , s : str ) - int : if len ( s ) == 0 : return 0 index = len ( s ) - 1 while ( s [ index ] == \\n or s [ index ] == ) and index = 0 : index -= 1 res = 0 for i in range ( index , - 1 , - 1 ): if s [ i ] == : break else : res += 1 return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/051-060/#059","text":"\u9762\u8bd5\u7ecf\u5178\u9898 \u7ed9\u5b9a\u4e00\u4e2an\uff0c\u751f\u6210\u4e00\u4e2an^2\u7684\u87ba\u65cb\u77e9\u9635 \u66b4\u529b\u51fa\u5947\u8ff9 \u8003\u9a8c\u57fa\u672c\u7684\u8fb9\u754c\u95ee\u9898","title":"059"},{"location":"LeetCode/vol 0/051-060/#_6","text":"\u66b4\u529b\u5c31\u5b8c\u4e8b\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def generateMatrix ( self , n ): :type n: int :rtype: List[List[int]] if n == 0 : return [] res = [[ 0 for i in range ( n )] for i in range ( n )] rowStart , colStart = 0 , 0 rowEnd , colEnd = n - 1 , n - 1 num = 1 while rowStart = rowEnd and colStart = colEnd : for j in range ( colStart , colEnd + 1 ): res [ rowStart ][ j ] = num num += 1 rowStart += 1 for i in range ( rowStart , rowEnd + 1 ): res [ i ][ colEnd ] = num num += 1 colEnd -= 1 for j in range ( colEnd , colStart - 1 , - 1 ): res [ rowEnd ][ j ] = num num += 1 rowEnd -= 1 for i in range ( rowEnd , rowStart - 1 , - 1 ): res [ i ][ colStart ] = num num += 1 colStart += 1 return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/051-060/#060","text":"Todo \u7ed9\u5b9a\u4e24\u4e2a\u6570n\u548ck\uff0c\u6c42\u75311\uff0c2\uff0c\u2026\u2026\uff0cn\u6784\u6210\u7684n\u4e2a\u6570\u7ec4\u6210\u7b2ck\u4e2a\u5168\u6392\u5217 1 2 3 4 5 6 7 8 9 10 By listing and labeling all of the permutations in order, we get the following sequence for n = 3: 123 132 213 231 312 321 Given n and k, return the kth permutation sequence. \u60f3\u6cd5 \u6240\u4ee5\u8fd8\u662f\u9003\u4e0d\u5f00\u5168\u6392\u5217 \u5168\u6392\u5217\u7684\u516c\u5f0f\u4e3a A^m_n=\\frac{n!}{(n-m)!} A^m_n=\\frac{n!}{(n-m)!} \uff0c\u6240\u4ee5 A^n_n=n! A^n_n=n! \u4ee51\u5f00\u5934\u7684\u6392\u5217\u6709(n-1)!\u4e2a \u6839\u636e\u7ed9\u5b9a\u7684k\u786e\u5b9a\u662f\u4ec0\u4e48\u6570\u5b57\u5f00\u5934\uff1f\u9012\u5f52\uff1f","title":"060"},{"location":"LeetCode/vol 0/061-070/","text":"061 \u770b\u6837\u5b50\u662f\u7ed9\u5b9a\u4e00\u4e2a\u94fe\u8868\uff0c\u4ece\u5012\u6570\u7b2ck\u4e2a\u8282\u70b9\u540e\u7ffb\u8f6c 1 2 3 4 5 6 7 8 9 10 11 12 13 Input: 1- 2- 3- 4- 5- NULL, k = 2 Output: 4- 5- 1- 2- 3- NULL Explanation: rotate 1 steps to the right: 5- 1- 2- 3- 4- NULL rotate 2 steps to the right: 4- 5- 1- 2- 3- NULL Input: 0- 1- 2- NULL, k = 4 Output: 2- 0- 1- NULL Explanation: rotate 1 steps to the right: 2- 0- 1- NULL rotate 2 steps to the right: 1- 2- 0- NULL rotate 3 steps to the right: 0- 1- 2- NULL rotate 4 steps to the right: 2- 0- 1- NULL \u60f3\u6cd5 \u8fde\u6210\u4e00\u4e2a\u73af\uff0c\u63a5\u7740\u904d\u5386 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def rotateRight ( self , head : ListNode , k : int ) - ListNode : if head == None : return None count = 0 tmp = head while tmp : tmp = tmp . next count += 1 # print(count) p , linkedNode = head , head for _ in range ( k % count ): linkedNode = linkedNode . next while p . next and linkedNode . next : p = p . next linkedNode = linkedNode . next linkedNode . next = head res = p . next p . next = None return res 062 \u72ec\u7279\u8def\u5f84\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u673a\u5668\u4eba\u548c\u4e00\u4e2am*n\u7684\u683c\u5b50\u677f\uff0c\u673a\u5668\u4eba\u667a\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\uff0c\u4ece\u5de6\u4e0a\u5230\u53f3\u4e0b\uff0c\u6709\u591a\u5c11\u4e0d\u4e00\u6837\u7684\u8def\u5f84 \u60f3\u6cd5 \u611f\u89c9\u7c7b\u4f3cDP\uff0c\u9012\u5f52\u611f\u89c9\u4e5f\u884c \u5982\u679c\u662fDP\u7684\u8bdd: DP[i][j]\u4e3aDP[i-1][j]+dp[i][j-1]+dp[i-1][j-1]+2 \u591a\u8003\u8651\u4e86dp[i-1][j-1]\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u4ecedp[i-1][j-1]\u5230\u662f\u53ef\u4ee5\u5230dp[i-1][j]\u6216dp[i][j-1]\u7684\uff0c\u91cd\u590d\u8003\u8651 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 class Solution : def uniquePaths ( self , m : int , n : int ) - int : dp = [[ 0 for _ in range ( n )] for _ in range ( m )] for i in range ( m ): dp [ i ][ 0 ] = 1 for j in range ( n ): dp [ 0 ][ j ] = 1 for i in range ( 1 , m ): for j in range ( 1 , n ): dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] #+ dp[i - 1][j - 1] + 2 return dp [ - 1 ][ - 1 ] 066 \u7ed9\u5b9a\u4e00\u4e2a\u975e\u7a7a\u7684\u6570\u7ec4\uff0c\u7136\u540e\u6700\u540e\u4e00\u4e2a\u6570\u52a0\u4e00\uff1f \u6bcf\u4e2adigits[i]\u53ea\u80fd\u75310-9\u7ec4\u6210 1 2 input: 9 ouput: 1,0 \u6cd5\u4e00 \u66b4\u529b\u4e4b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def plusOne ( self , digits ): :type digits: List[int] :rtype: List[int] res = [] num = 0 carry = 1 for digit in digits [:: - 1 ]: num += digit * carry carry *= 10 num += 1 while num : res . append ( num % 10 ) num //= 10 return res [:: - 1 ] \u6cd5\u4e8c \u904d\u5386\u6570\u7ec4\uff0c\u9047\u52309\u8fdb\u4f4d\uff0c\u5982\u679c\u8fdb\u4f4d\u540e\u4e0d\u80fd\u6ee1\u8db3\u589e\u52a0\u4e00\u4e2a1\uff0c\u5426\u5219\u5bf9\u8fdb\u4f4d\u540e\u7684\u7684\u6570\u5b57\u52a0\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def plusOne ( self , digits ): :type digits: List[int] :rtype: List[int] i = len ( digits ) - 1 while digits [ i ] == 9 : digits [ i ] = 0 i -= 1 if i 0 : digits . insert ( 0 , 1 ) return digits digits [ i ] += 1 return digits 067 \u7ed9\u5b9a\u4e24\u4e2a\u7531\u5b57\u7b26'0'\uff0c'1'\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u8fd9\u4e24\u4e2a\u7684\u5b57\u7b26\u4e32\u6240\u4ee3\u8868\u7684\u6570\u5b57\u7684\u548c \u4e8c\u8fdb\u5236\u52a0 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def addBinary ( self , a , b ): :type a: str :type b: str :rtype: str if len ( b ) len ( a ): return self . addBinary ( b , a ) a = list ( map ( lambda x : int ( x ), a )) b = list ( map ( lambda x : int ( x ), b )) i = 0 carry = 0 res = [] while i len ( a ): if i = len ( b ): cb = 0 else : cb = b [ len ( b ) - i - 1 ] sum = a [ len ( a ) - i - 1 ] + cb + carry if sum 1 : res . append ( str ( sum % 2 )) carry = sum // 2 else : res . append ( str ( sum )) carry = 0 i += 1 if carry != 0 : res . append ( 1 ) return . join ( res [:: - 1 ]) \u6cd5\u4e8c \u9012\u5f52 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution ( object ): def addBinary ( self , a , b , carried = 0 ): if ( not a ) or ( not b ): return str ( carried ) if carried else elif ( not a ): a = 0 elif ( not b ): b = 0 summed = int ( b [ - 1 ]) + int ( a [ - 1 ]) + carried carried = summed / 2 bit = summed % 2 return self . addBinary ( a [: - 1 ], b [: - 1 ], carried ) + str ( bit ) 069 \u9762\u8bd5\u7ecf\u5178\u9898 \u5b9e\u73b0 sqrt \u65b9\u6cd5 \u60f3\u6cd5 \u4e8c\u5206 \u725b\u987f\u6cd5 \u542c\u8bf4\u7684\uff0c\u4f46\u662f\u5177\u4f53\u600e\u6837\u8fd8\u662f\u4e0d\u4f1a\u3002\u3002\u3002 \u90a3\u4e48\u9996\u5148\u8bd5\u8bd5\u4e8c\u5206\u6cd5 \u6ce8\u610f\u8fb9\u754c\u6761\u4ef6 \u6cd5\u4e00 \u53cd\u6b63\u66b4\u529b\u5c31\u662f\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def mySqrt ( self , x ): :type x: int :rtype: int left = 0 right = x while right left : middle = left + ( right - left ) // 2 if middle * middle == x : return middle elif middle * middle x : left = middle + 1 else : right = middle - 1 if right * right == x : return right elif left * left x : return left - 1 else : return left \u6cd5\u4e8c 1 2 3 4 5 6 7 8 9 10 class Solution : def mySqrt ( self , x ): :type x: int :rtype: int r = x while r * r x : r = ( r + x / r ) / 2 return r 1 2 3 4 5 6 7 8 9 10 11 class Solution : def mySqrt ( self , x ): l , r = 0 , x while l = r : mid = l + ( r - l ) // 2 #\u6ce8\u610f if mid * mid = x ( mid + 1 ) * ( mid + 1 ): return mid elif x mid * mid : r = mid #\u6ce8\u610f else : l = mid + 1 070 \u722c\u68af\u5b50\uff0c\u7ecf\u5178\u7684\u9762\u8bd5\u9898 \u7ed9\u5b9a\u4e00\u4e2an\u7684\u53f0\u9636\uff0c\u6bcf\u6b21\u722c1\u4e2a\u62162\u4e2a\u53f0\u9636\uff0c\u603b\u5171\u8ba1\u7b97\u591a\u5c11\u79cd\u65b9\u5f0f \u60f3\u6cd5 \u9012\u5f52 \u627e\u89c4\u5f8b \u9996\u5148\u662f\u9012\u5f52\uff0c\u5bf9\u4e8e\u4e00\u4e2an\u7684\u53f0\u9636\uff0c\u53ef\u4ee5\u7531n-1\u53f0\u9636\u722c\u4e00\u4e2a\u68af\u5b50\uff0c\u4e0en-2\u4e2a\u53f0\u9636\u722c\u4e24\u4e2a\u68af\u5b50 \u56e0\u6b64f(n)=f(n-1)+f(n-2) \u7136\u540e\u4f7f\u7528\u9012\u5f52\u5c31\u8d85\u65f6\u4e86 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def climbStairs ( self , n ): :type n: int :rtype: int if n == 1 : return 1 elif n == 2 : return 2 else : one_step_before = 1 two_step_before = 2 res = 0 for _ in range ( n - 2 ): res = one_step_before + two_step_before one_step_before = two_step_before two_step_before = res return res","title":"061 070"},{"location":"LeetCode/vol 0/061-070/#061","text":"\u770b\u6837\u5b50\u662f\u7ed9\u5b9a\u4e00\u4e2a\u94fe\u8868\uff0c\u4ece\u5012\u6570\u7b2ck\u4e2a\u8282\u70b9\u540e\u7ffb\u8f6c 1 2 3 4 5 6 7 8 9 10 11 12 13 Input: 1- 2- 3- 4- 5- NULL, k = 2 Output: 4- 5- 1- 2- 3- NULL Explanation: rotate 1 steps to the right: 5- 1- 2- 3- 4- NULL rotate 2 steps to the right: 4- 5- 1- 2- 3- NULL Input: 0- 1- 2- NULL, k = 4 Output: 2- 0- 1- NULL Explanation: rotate 1 steps to the right: 2- 0- 1- NULL rotate 2 steps to the right: 1- 2- 0- NULL rotate 3 steps to the right: 0- 1- 2- NULL rotate 4 steps to the right: 2- 0- 1- NULL \u60f3\u6cd5 \u8fde\u6210\u4e00\u4e2a\u73af\uff0c\u63a5\u7740\u904d\u5386","title":"061"},{"location":"LeetCode/vol 0/061-070/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def rotateRight ( self , head : ListNode , k : int ) - ListNode : if head == None : return None count = 0 tmp = head while tmp : tmp = tmp . next count += 1 # print(count) p , linkedNode = head , head for _ in range ( k % count ): linkedNode = linkedNode . next while p . next and linkedNode . next : p = p . next linkedNode = linkedNode . next linkedNode . next = head res = p . next p . next = None return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/061-070/#062","text":"\u72ec\u7279\u8def\u5f84\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u673a\u5668\u4eba\u548c\u4e00\u4e2am*n\u7684\u683c\u5b50\u677f\uff0c\u673a\u5668\u4eba\u667a\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\uff0c\u4ece\u5de6\u4e0a\u5230\u53f3\u4e0b\uff0c\u6709\u591a\u5c11\u4e0d\u4e00\u6837\u7684\u8def\u5f84 \u60f3\u6cd5 \u611f\u89c9\u7c7b\u4f3cDP\uff0c\u9012\u5f52\u611f\u89c9\u4e5f\u884c \u5982\u679c\u662fDP\u7684\u8bdd: DP[i][j]\u4e3aDP[i-1][j]+dp[i][j-1]+dp[i-1][j-1]+2 \u591a\u8003\u8651\u4e86dp[i-1][j-1]\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u4ecedp[i-1][j-1]\u5230\u662f\u53ef\u4ee5\u5230dp[i-1][j]\u6216dp[i][j-1]\u7684\uff0c\u91cd\u590d\u8003\u8651","title":"062"},{"location":"LeetCode/vol 0/061-070/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def uniquePaths ( self , m : int , n : int ) - int : dp = [[ 0 for _ in range ( n )] for _ in range ( m )] for i in range ( m ): dp [ i ][ 0 ] = 1 for j in range ( n ): dp [ 0 ][ j ] = 1 for i in range ( 1 , m ): for j in range ( 1 , n ): dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] #+ dp[i - 1][j - 1] + 2 return dp [ - 1 ][ - 1 ]","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/061-070/#066","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u7a7a\u7684\u6570\u7ec4\uff0c\u7136\u540e\u6700\u540e\u4e00\u4e2a\u6570\u52a0\u4e00\uff1f \u6bcf\u4e2adigits[i]\u53ea\u80fd\u75310-9\u7ec4\u6210 1 2 input: 9 ouput: 1,0","title":"066"},{"location":"LeetCode/vol 0/061-070/#_3","text":"\u66b4\u529b\u4e4b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def plusOne ( self , digits ): :type digits: List[int] :rtype: List[int] res = [] num = 0 carry = 1 for digit in digits [:: - 1 ]: num += digit * carry carry *= 10 num += 1 while num : res . append ( num % 10 ) num //= 10 return res [:: - 1 ]","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/061-070/#_4","text":"\u904d\u5386\u6570\u7ec4\uff0c\u9047\u52309\u8fdb\u4f4d\uff0c\u5982\u679c\u8fdb\u4f4d\u540e\u4e0d\u80fd\u6ee1\u8db3\u589e\u52a0\u4e00\u4e2a1\uff0c\u5426\u5219\u5bf9\u8fdb\u4f4d\u540e\u7684\u7684\u6570\u5b57\u52a0\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def plusOne ( self , digits ): :type digits: List[int] :rtype: List[int] i = len ( digits ) - 1 while digits [ i ] == 9 : digits [ i ] = 0 i -= 1 if i 0 : digits . insert ( 0 , 1 ) return digits digits [ i ] += 1 return digits","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 0/061-070/#067","text":"\u7ed9\u5b9a\u4e24\u4e2a\u7531\u5b57\u7b26'0'\uff0c'1'\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u8fd9\u4e24\u4e2a\u7684\u5b57\u7b26\u4e32\u6240\u4ee3\u8868\u7684\u6570\u5b57\u7684\u548c \u4e8c\u8fdb\u5236\u52a0","title":"067"},{"location":"LeetCode/vol 0/061-070/#_5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def addBinary ( self , a , b ): :type a: str :type b: str :rtype: str if len ( b ) len ( a ): return self . addBinary ( b , a ) a = list ( map ( lambda x : int ( x ), a )) b = list ( map ( lambda x : int ( x ), b )) i = 0 carry = 0 res = [] while i len ( a ): if i = len ( b ): cb = 0 else : cb = b [ len ( b ) - i - 1 ] sum = a [ len ( a ) - i - 1 ] + cb + carry if sum 1 : res . append ( str ( sum % 2 )) carry = sum // 2 else : res . append ( str ( sum )) carry = 0 i += 1 if carry != 0 : res . append ( 1 ) return . join ( res [:: - 1 ])","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/061-070/#_6","text":"\u9012\u5f52 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution ( object ): def addBinary ( self , a , b , carried = 0 ): if ( not a ) or ( not b ): return str ( carried ) if carried else elif ( not a ): a = 0 elif ( not b ): b = 0 summed = int ( b [ - 1 ]) + int ( a [ - 1 ]) + carried carried = summed / 2 bit = summed % 2 return self . addBinary ( a [: - 1 ], b [: - 1 ], carried ) + str ( bit )","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 0/061-070/#069","text":"\u9762\u8bd5\u7ecf\u5178\u9898 \u5b9e\u73b0 sqrt \u65b9\u6cd5 \u60f3\u6cd5 \u4e8c\u5206 \u725b\u987f\u6cd5 \u542c\u8bf4\u7684\uff0c\u4f46\u662f\u5177\u4f53\u600e\u6837\u8fd8\u662f\u4e0d\u4f1a\u3002\u3002\u3002 \u90a3\u4e48\u9996\u5148\u8bd5\u8bd5\u4e8c\u5206\u6cd5 \u6ce8\u610f\u8fb9\u754c\u6761\u4ef6","title":"069"},{"location":"LeetCode/vol 0/061-070/#_7","text":"\u53cd\u6b63\u66b4\u529b\u5c31\u662f\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def mySqrt ( self , x ): :type x: int :rtype: int left = 0 right = x while right left : middle = left + ( right - left ) // 2 if middle * middle == x : return middle elif middle * middle x : left = middle + 1 else : right = middle - 1 if right * right == x : return right elif left * left x : return left - 1 else : return left","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/061-070/#_8","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def mySqrt ( self , x ): :type x: int :rtype: int r = x while r * r x : r = ( r + x / r ) / 2 return r 1 2 3 4 5 6 7 8 9 10 11 class Solution : def mySqrt ( self , x ): l , r = 0 , x while l = r : mid = l + ( r - l ) // 2 #\u6ce8\u610f if mid * mid = x ( mid + 1 ) * ( mid + 1 ): return mid elif x mid * mid : r = mid #\u6ce8\u610f else : l = mid + 1","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 0/061-070/#070","text":"\u722c\u68af\u5b50\uff0c\u7ecf\u5178\u7684\u9762\u8bd5\u9898 \u7ed9\u5b9a\u4e00\u4e2an\u7684\u53f0\u9636\uff0c\u6bcf\u6b21\u722c1\u4e2a\u62162\u4e2a\u53f0\u9636\uff0c\u603b\u5171\u8ba1\u7b97\u591a\u5c11\u79cd\u65b9\u5f0f \u60f3\u6cd5 \u9012\u5f52 \u627e\u89c4\u5f8b \u9996\u5148\u662f\u9012\u5f52\uff0c\u5bf9\u4e8e\u4e00\u4e2an\u7684\u53f0\u9636\uff0c\u53ef\u4ee5\u7531n-1\u53f0\u9636\u722c\u4e00\u4e2a\u68af\u5b50\uff0c\u4e0en-2\u4e2a\u53f0\u9636\u722c\u4e24\u4e2a\u68af\u5b50 \u56e0\u6b64f(n)=f(n-1)+f(n-2) \u7136\u540e\u4f7f\u7528\u9012\u5f52\u5c31\u8d85\u65f6\u4e86","title":"070"},{"location":"LeetCode/vol 0/061-070/#_9","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def climbStairs ( self , n ): :type n: int :rtype: int if n == 1 : return 1 elif n == 2 : return 2 else : one_step_before = 1 two_step_before = 2 res = 0 for _ in range ( n - 2 ): res = one_step_before + two_step_before one_step_before = two_step_before two_step_before = res return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/071-080/","text":"071 \u7ed9\u5b9a\u4e00\u4e2a\u7c7bUnix\u7684\u8def\u5f84\u683c\u5f0f\uff0c\u89c4\u8303\u8be5\u8def\u5f84 1 2 3 4 5 6 7 8 9 10 11 Input: /home/ Output: /home Explanation: Note that there is no trailing slash after the last directory name. Input: /../ Output: / Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Input: /home//foo/ Output: /home/foo Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. \u60f3\u6cd5 \u770b\u6837\u5b50\u662f\u7528\u6808\u6765\u5b9e\u73b0\uff1f \u4e0d\u8fc7\u770b\u6837\u5b50\u66b4\u529b\u7684\u65b9\u5f0f\u66f4\u597d \u6cd5\u4e00 \u6000\u7591\u81ea\u5df1\u662f\u5426\u601d\u8def\u9519\u8bef\uff0c\u7ed3\u679c\u53d1\u73b0\u601d\u8def\u6b63\u786e\uff0c\u4f46\u662f\u9519\u8bef\u5728\u9898\u76ee\u7684\u7406\u89e3\u4e0a 1 2 3 4 5 6 7 8 9 10 11 class Solution ( object ): def simplifyPath ( self , path ): places = [ p for p in path . split ( / ) if p != . and p != ] stack = [] for p in places : if p == .. : if len ( stack ) 0 : stack . pop () else : stack . append ( p ) return / + / . join ( stack ) \u9519\u8bef 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def simplifyPath ( self , path : str ) - str : pathList = path . split ( / ) if pathList [ - 1 ] == / : pathList . pop ( - 1 ) index = 0 while index len ( pathList ): if pathList [ index ] == . or pathList [ index ] == : pathList . pop ( index ) elif pathList [ index ] == / and pathList [ index + 1 ] == / : pathList . pop ( index ) elif pathList [ index ] == .. : pathList . pop ( index ) if index != 0 : pathList . pop ( index - 1 ) index -= 1 else : # \u8fd9\u91cc\u51fa\u9519\u4e86\uff0c\u5e76\u4e0d\u662f\u76f4\u63a5\u8fd4\u56de\uff0c\u601d\u8def\u4e0d\u6e05\u6670\u6240\u4ee5\u51fa\u9519 return / else : index += 1 return / + / . join ( pathList )","title":"071 080"},{"location":"LeetCode/vol 0/071-080/#071","text":"\u7ed9\u5b9a\u4e00\u4e2a\u7c7bUnix\u7684\u8def\u5f84\u683c\u5f0f\uff0c\u89c4\u8303\u8be5\u8def\u5f84 1 2 3 4 5 6 7 8 9 10 11 Input: /home/ Output: /home Explanation: Note that there is no trailing slash after the last directory name. Input: /../ Output: / Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Input: /home//foo/ Output: /home/foo Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. \u60f3\u6cd5 \u770b\u6837\u5b50\u662f\u7528\u6808\u6765\u5b9e\u73b0\uff1f \u4e0d\u8fc7\u770b\u6837\u5b50\u66b4\u529b\u7684\u65b9\u5f0f\u66f4\u597d","title":"071"},{"location":"LeetCode/vol 0/071-080/#_1","text":"\u6000\u7591\u81ea\u5df1\u662f\u5426\u601d\u8def\u9519\u8bef\uff0c\u7ed3\u679c\u53d1\u73b0\u601d\u8def\u6b63\u786e\uff0c\u4f46\u662f\u9519\u8bef\u5728\u9898\u76ee\u7684\u7406\u89e3\u4e0a 1 2 3 4 5 6 7 8 9 10 11 class Solution ( object ): def simplifyPath ( self , path ): places = [ p for p in path . split ( / ) if p != . and p != ] stack = [] for p in places : if p == .. : if len ( stack ) 0 : stack . pop () else : stack . append ( p ) return / + / . join ( stack )","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/071-080/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def simplifyPath ( self , path : str ) - str : pathList = path . split ( / ) if pathList [ - 1 ] == / : pathList . pop ( - 1 ) index = 0 while index len ( pathList ): if pathList [ index ] == . or pathList [ index ] == : pathList . pop ( index ) elif pathList [ index ] == / and pathList [ index + 1 ] == / : pathList . pop ( index ) elif pathList [ index ] == .. : pathList . pop ( index ) if index != 0 : pathList . pop ( index - 1 ) index -= 1 else : # \u8fd9\u91cc\u51fa\u9519\u4e86\uff0c\u5e76\u4e0d\u662f\u76f4\u63a5\u8fd4\u56de\uff0c\u601d\u8def\u4e0d\u6e05\u6670\u6240\u4ee5\u51fa\u9519 return / else : index += 1 return / + / . join ( pathList )","title":"\u9519\u8bef"},{"location":"LeetCode/vol 0/081-090/","text":"083 \u5728\u6392\u5e8f\u94fe\u8868\u4e2d\u5220\u9664\u91cd\u590d\u7684\u5143\u7d20 \u60f3\u6cd5 \u6ca1\u60f3\u6cd5\uff0c\u66b4\u529b \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def deleteDuplicates ( self , head ): :type head: ListNode :rtype: ListNode HEAD = ListNode ( HEAD ) HEAD . next = head p = HEAD . next while p : if p . next and p . val != p . next . val : p = p . next else : if p . next : p . next = p . next . next else : p . next = None break return HEAD . next 088 \u5408\u5e76\u6709\u5e8f\u6570\u7ec4\uff0c\u5c06nums2\u5408\u5e76\u5230nums1\u91cc\uff0c\u8fd9\u91ccnums1\u6709\u8db3\u591f\u591a\u7684\u7684\u7a7a\u95f4 \u60f3\u6cd5 \u5148\u5b9e\u73b0\u4e2a\u66b4\u529b\u7684\u7b97\u6cd5 \u9996\u5148\u9010\u4e2a\u5bf9\u6bd4\u4e24\u4e2a\u6570\u7ec4\u7684\u6570\u503c\uff0c\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\uff1a nums1[i] =nums2[j] \u90a3\u4e48\u76f4\u63a5\u5728nums\u7b2ci\u5904\u63d2\u5165nums[j]\uff0ci+=1,j+=1 (\u6ce8\u610f\uff0c\u8fd9\u91cc\u4e4b\u524d\u60f3\u7684\u662fi+=2\uff0c\u6ca1\u8003\u8651\u5230\u63d2\u5165\u4e4b\u524dnums[j+1]\u8fd8\u662f\u6bd4nums[i]\u5c0f\u7684\u60c5\u5f62) nums1[i] nums2[j]\uff0c\u90a3\u4e48\u5411\u540e\u5bfb\u627e\uff0ci+=1 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def merge ( self , nums1 , m : int , nums2 , n : int ) - None : Do not return anything, modify nums1 in-place instead. i = 0 j = 0 sumCount = m + n while i m and j n : if nums1 [ i ] = nums2 [ j ]: self . insertNums ( nums1 , i , nums2 [ j ]) i += 1 j += 1 m += 1 else : i += 1 if i sumCount and n 0 and j n : for index in range ( i , sumCount ): nums1 [ index ] = nums2 [ j ] j += 1 def insertNums ( self , nums , index , val ): for j in range ( len ( nums ) - 1 , index , - 1 ): nums [ j ] = nums [ j - 1 ] nums [ index ] = val","title":"081 090"},{"location":"LeetCode/vol 0/081-090/#083","text":"\u5728\u6392\u5e8f\u94fe\u8868\u4e2d\u5220\u9664\u91cd\u590d\u7684\u5143\u7d20 \u60f3\u6cd5 \u6ca1\u60f3\u6cd5\uff0c\u66b4\u529b","title":"083"},{"location":"LeetCode/vol 0/081-090/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def deleteDuplicates ( self , head ): :type head: ListNode :rtype: ListNode HEAD = ListNode ( HEAD ) HEAD . next = head p = HEAD . next while p : if p . next and p . val != p . next . val : p = p . next else : if p . next : p . next = p . next . next else : p . next = None break return HEAD . next","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 0/081-090/#088","text":"\u5408\u5e76\u6709\u5e8f\u6570\u7ec4\uff0c\u5c06nums2\u5408\u5e76\u5230nums1\u91cc\uff0c\u8fd9\u91ccnums1\u6709\u8db3\u591f\u591a\u7684\u7684\u7a7a\u95f4 \u60f3\u6cd5 \u5148\u5b9e\u73b0\u4e2a\u66b4\u529b\u7684\u7b97\u6cd5 \u9996\u5148\u9010\u4e2a\u5bf9\u6bd4\u4e24\u4e2a\u6570\u7ec4\u7684\u6570\u503c\uff0c\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\uff1a nums1[i] =nums2[j] \u90a3\u4e48\u76f4\u63a5\u5728nums\u7b2ci\u5904\u63d2\u5165nums[j]\uff0ci+=1,j+=1 (\u6ce8\u610f\uff0c\u8fd9\u91cc\u4e4b\u524d\u60f3\u7684\u662fi+=2\uff0c\u6ca1\u8003\u8651\u5230\u63d2\u5165\u4e4b\u524dnums[j+1]\u8fd8\u662f\u6bd4nums[i]\u5c0f\u7684\u60c5\u5f62) nums1[i] nums2[j]\uff0c\u90a3\u4e48\u5411\u540e\u5bfb\u627e\uff0ci+=1","title":"088"},{"location":"LeetCode/vol 0/081-090/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def merge ( self , nums1 , m : int , nums2 , n : int ) - None : Do not return anything, modify nums1 in-place instead. i = 0 j = 0 sumCount = m + n while i m and j n : if nums1 [ i ] = nums2 [ j ]: self . insertNums ( nums1 , i , nums2 [ j ]) i += 1 j += 1 m += 1 else : i += 1 if i sumCount and n 0 and j n : for index in range ( i , sumCount ): nums1 [ index ] = nums2 [ j ] j += 1 def insertNums ( self , nums , index , val ): for j in range ( len ( nums ) - 1 , index , - 1 ): nums [ j ] = nums [ j - 1 ] nums [ index ] = val","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 1/091-100/","text":"100 \u7ed9\u5b9a\u4e24\u4e2a\u6811\uff0c\u5224\u65ad\u8fd9\u4e24\u68f5\u6811\u662f\u5426\u662f\u76f8\u540c\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] Output: true Input: 1 1 / \\ 2 2 [1,2], [1,null,2] Output: false Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] Output: false \u60f3\u6cd5 \u90a3\u5c31\u904d\u5386\u54af\uff0c\u5982\u679c\u4e00\u4e2a\u6570\u7684\u4e2d\u5e8f\u904d\u5386\u548c\u524d\u5e8f\u904d\u5386\u662f\u4e00\u6837\u7684\u90a3\u5c31\u662f\u76f8\u540c\u7684 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 class Solution : def isSameTree ( self , p , q ): if p and q : if p . val == q . val and self . isSameTree ( p . left , q . left ) and self . isSameTree ( p . right , q . right ): return True elif p is None and q is None : return True return False 155 \u5b9e\u73b0\u6700\u5c0f\u6808 \u60f3\u6cd5 \u591apush\u4e00\u4e2a\u6700\u5c0f\u6570\u54af \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MinStack : def __init__ ( self ): initialize your data structure here. self . min = float ( inf ) self . stack = [] def push ( self , x : int ) - None : if x = self . min : self . stack . append ( self . min ) self . min = x self . stack . append ( x ) def pop ( self ) - None : if self . stack . pop () = self . min : self . min = self . stack . pop () def top ( self ) - int : return self . stack [ - 1 ] def getMin ( self ) - int : return self . min","title":"091 100"},{"location":"LeetCode/vol 1/091-100/#100","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6811\uff0c\u5224\u65ad\u8fd9\u4e24\u68f5\u6811\u662f\u5426\u662f\u76f8\u540c\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] Output: true Input: 1 1 / \\ 2 2 [1,2], [1,null,2] Output: false Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] Output: false \u60f3\u6cd5 \u90a3\u5c31\u904d\u5386\u54af\uff0c\u5982\u679c\u4e00\u4e2a\u6570\u7684\u4e2d\u5e8f\u904d\u5386\u548c\u524d\u5e8f\u904d\u5386\u662f\u4e00\u6837\u7684\u90a3\u5c31\u662f\u76f8\u540c\u7684","title":"100"},{"location":"LeetCode/vol 1/091-100/#_1","text":"1 2 3 4 5 6 7 8 9 class Solution : def isSameTree ( self , p , q ): if p and q : if p . val == q . val and self . isSameTree ( p . left , q . left ) and self . isSameTree ( p . right , q . right ): return True elif p is None and q is None : return True return False","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 1/091-100/#155","text":"\u5b9e\u73b0\u6700\u5c0f\u6808 \u60f3\u6cd5 \u591apush\u4e00\u4e2a\u6700\u5c0f\u6570\u54af","title":"155"},{"location":"LeetCode/vol 1/091-100/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MinStack : def __init__ ( self ): initialize your data structure here. self . min = float ( inf ) self . stack = [] def push ( self , x : int ) - None : if x = self . min : self . stack . append ( self . min ) self . min = x self . stack . append ( x ) def pop ( self ) - None : if self . stack . pop () = self . min : self . min = self . stack . pop () def top ( self ) - int : return self . stack [ - 1 ] def getMin ( self ) - int : return self . min","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 1/151-160/","text":"160 \u5bfb\u627e\u4e24\u4e2a\u8282\u70b9\u7684\u8fde\u63a5\u5904 1 2 3 Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. \u60f3\u6cd5 \u8fd4\u56de\u7684\u662f\u94fe\u8868\u8282\u70b9\u8fd9\u4e2a\u5b9e\u4f8b \u94fe\u8868\u9898\u5224\u65ad\u7ed3\u6784\u5927\u90fd\u662f\u904d\u5386\u4e0a\u4e0b\u529f\u592b\uff0c\u6bd4\u5982\u5feb\u6162\u8282\u70b9 \u8fd9\u91cc\u53ef\u4ee5\u7528\uff0c\u5047\u8bbe\u94fe\u8868A\u4e0e\u94fe\u8868B\u6709\u516c\u5171\u8282\u70b9\uff0c\u8fd9\u91cc\u6709\u4e24\u4e2a\u6307\u9488pa\uff0cpb pa\u5f53A\u904d\u5386\u5b8c\u540e\u8d70B\uff0c\u540c\u7406pb\u904d\u5386B\u540e\u8d70a\uff1b\u8d70\u5230\u4ea4\u70b9\u7684\u65f6\u5019\uff0c\u4e24\u4e2a\u6307\u9488\u8d70\u7684\u8ddd\u79bb\u80af\u5b9a\u662f\u4e00\u6837\u7684 1 2 3 4 5 6 7 8 9 \u8fd9\u91cc\u8bbe A = 1 2 3 4 5 6 7 8 B = 9 7 6 5 4 3 4 5 6 7 8 pa = 1 2 3 4 5 6 7 8 9 7 6 5 4 3 pb = 9 7 6 5 4 3 4 5 6 7 8 1 2 3 3+5 + 6 6+5 + 3 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution ( object ): def getIntersectionNode ( self , headA , headB ): :type head1, head1: ListNode :rtype: ListNode if headA is None or headB is None : return pa = headA pb = headB while pa != pb : pa = headB if pa is None else pa . next pb = headA if pb is None else pb . next return pa","title":"151 160"},{"location":"LeetCode/vol 1/151-160/#160","text":"\u5bfb\u627e\u4e24\u4e2a\u8282\u70b9\u7684\u8fde\u63a5\u5904 1 2 3 Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. \u60f3\u6cd5 \u8fd4\u56de\u7684\u662f\u94fe\u8868\u8282\u70b9\u8fd9\u4e2a\u5b9e\u4f8b \u94fe\u8868\u9898\u5224\u65ad\u7ed3\u6784\u5927\u90fd\u662f\u904d\u5386\u4e0a\u4e0b\u529f\u592b\uff0c\u6bd4\u5982\u5feb\u6162\u8282\u70b9 \u8fd9\u91cc\u53ef\u4ee5\u7528\uff0c\u5047\u8bbe\u94fe\u8868A\u4e0e\u94fe\u8868B\u6709\u516c\u5171\u8282\u70b9\uff0c\u8fd9\u91cc\u6709\u4e24\u4e2a\u6307\u9488pa\uff0cpb pa\u5f53A\u904d\u5386\u5b8c\u540e\u8d70B\uff0c\u540c\u7406pb\u904d\u5386B\u540e\u8d70a\uff1b\u8d70\u5230\u4ea4\u70b9\u7684\u65f6\u5019\uff0c\u4e24\u4e2a\u6307\u9488\u8d70\u7684\u8ddd\u79bb\u80af\u5b9a\u662f\u4e00\u6837\u7684 1 2 3 4 5 6 7 8 9 \u8fd9\u91cc\u8bbe A = 1 2 3 4 5 6 7 8 B = 9 7 6 5 4 3 4 5 6 7 8 pa = 1 2 3 4 5 6 7 8 9 7 6 5 4 3 pb = 9 7 6 5 4 3 4 5 6 7 8 1 2 3 3+5 + 6 6+5 + 3","title":"160"},{"location":"LeetCode/vol 1/151-160/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution ( object ): def getIntersectionNode ( self , headA , headB ): :type head1, head1: ListNode :rtype: ListNode if headA is None or headB is None : return pa = headA pb = headB while pa != pb : pa = headB if pa is None else pa . next pb = headA if pb is None else pb . next return pa","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 5/531-540/","text":"538 \u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u5c06\u8fd9\u4e2a\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u7684\u6bcf\u4e2a\u503c\u53d8\u6210\u6bd4\u5b83\u8fd8\u8981\u5927\u7684\u6bcf\u4e2a\u5143\u7d20\u7684\u548c\uff08\u5305\u62ec\u81ea\u5df1\uff09 1 2 3 4 5 6 7 8 9 Input: The root of a Binary Search Tree like this: 5 / \\ 2 13 Output: The root of a Greater Tree like this: 18 / \\ 20 13 \u60f3\u6cd5 \u9996\u5148\u8fd9\u662f\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u9700\u8981\u5229\u7528\u8fd9\u4e2a\u7684\u7279\u6027\uff0c\u540e\u7eed\u904d\u5386\uff1f \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def convertBST ( self , root : TreeNode ) - TreeNode : self . valSum = 0 def __covertBSTHelper ( root : TreeNode ): if not root : return __covertBSTHelper ( root . right ) self . valSum += root . val root . val = self . valSum __covertBSTHelper ( root . left ) __covertBSTHelper ( root ) return root \u6cd5\u4e8c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def convertBST ( self , root : TreeNode ) - TreeNode : total = 0 stack = [] node = root while stack or node : while node : stack . append ( node ) node = node . right node = stack . pop () total += node . val node . val = total node = node . left return root","title":"531 540"},{"location":"LeetCode/vol 5/531-540/#538","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u5c06\u8fd9\u4e2a\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u7684\u6bcf\u4e2a\u503c\u53d8\u6210\u6bd4\u5b83\u8fd8\u8981\u5927\u7684\u6bcf\u4e2a\u5143\u7d20\u7684\u548c\uff08\u5305\u62ec\u81ea\u5df1\uff09 1 2 3 4 5 6 7 8 9 Input: The root of a Binary Search Tree like this: 5 / \\ 2 13 Output: The root of a Greater Tree like this: 18 / \\ 20 13 \u60f3\u6cd5 \u9996\u5148\u8fd9\u662f\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u9700\u8981\u5229\u7528\u8fd9\u4e2a\u7684\u7279\u6027\uff0c\u540e\u7eed\u904d\u5386\uff1f","title":"538"},{"location":"LeetCode/vol 5/531-540/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def convertBST ( self , root : TreeNode ) - TreeNode : self . valSum = 0 def __covertBSTHelper ( root : TreeNode ): if not root : return __covertBSTHelper ( root . right ) self . valSum += root . val root . val = self . valSum __covertBSTHelper ( root . left ) __covertBSTHelper ( root ) return root","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 5/531-540/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def convertBST ( self , root : TreeNode ) - TreeNode : total = 0 stack = [] node = root while stack or node : while node : stack . append ( node ) node = node . right node = stack . pop () total += node . val node . val = total node = node . left return root","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 6/651-660/","text":"654 \u6839\u636e\u4e00\u4e2a\u6570\u7ec4\uff0c\u6784\u5efa\u4e00\u4e2a\u4e8c\u53c9\u6811 \u6839\u8282\u70b9\u7684\u503c\u65f6\u8be5\u6570\u7ec4\u7684\u6700\u5927\u503c\uff0c\u5de6\u8fb9\u662f\u7531\u6700\u5927\u503c\u5de6\u8fb9\u90e8\u5206\u6784\u9020\u7684\u7684\u6700\u5927\u6570\uff0c\u53f3\u8fb9\u540c\u7406 1 2 3 4 5 6 7 8 9 10 Input: [3,2,1,6,0,5] Output: return the tree root node representing the following tree: 6 / \\ 3 5 \\ / 2 0 \\ 1 \u60f3\u6cd5 \u9012\u5f52\uff1f \u6216\u8005\u662f\u904d\u5386\uff1f \u5bf9\u4e8e\u6570\u7ec4\u7684\u6bcf\u4e2a\u503c\uff0c\u5982\u679c\u540e\u9762\u7684\u503c\u6bd4\u4e4b\u524d\u7684\u5927\uff0c\u90a3\u4e48TreeNode(vals[i+1]).left = TreeNode(vals[i])\uff0c\u7136\u540e\u8fd9\u6837\u904d\u5386\u4e0b\u53bb\uff1f\u5148\u8bd5\u8bd5\uff1f \u4e0d\u8fc7\u611f\u89c9\u8fd9\u9996\u5148\u9700\u8981\u628a\u6240\u6709\u7684\u8282\u70b9\u5148\u8bb0\u5f55\u4e0b\u6765\uff0c \u8bb0\u5f55\u5f15\u7528\uff1f \uff0c\u5b9e\u9645\u4e0a\u6548\u679c\u53ef\u80fd\u5e76\u4e0d\u597d\uff0c\u540c\u65f6\uff0c\u8fd8\u9700\u8981\u56de\u6eaf\u51fa\u4e4b\u524d\u7684\u6700\u5927\u6811\u7684\u8282\u70b9 \u770b\u6765\u8fd8\u662f\u7528\u9012\u5f52\u6bd4\u8f83\u597d \u6cd5\u4e00 \u7b80\u5355\u7684\u9012\u5f52\uff0c\u80fd\u5426\u8fdb\u4e00\u6b65\u4f18\u5316\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def constructMaximumBinaryTree ( self , nums ) - TreeNode : if len ( nums ) == 0 : return return self . __buildTree ( nums , 0 , len ( nums )) def __buildTree ( self , nums , start , end ): if start = end : return idx_max = start for i in range ( start + 1 , end ): if nums [ i ] nums [ idx_max ]: idx_max = i root = TreeNode ( nums [ idx_max ]) root . left = self . __buildTree ( nums , start , idx_max ) root . right = self . __buildTree ( nums , idx_max + 1 , end ) return root \u5176\u4ed6 \u5988\u7684\u6ca1\u533a\u522b\u554a\uff0c\u4e3a\u4ec0\u4e48\u90a3\u4e48\u5feb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def constructMaximumBinaryTree ( self , nums : List[int] ) - TreeNode : return self . constructTree ( nums ) def constructTree ( self , ls ): rootIndex = self . findMaxIndex ( ls ) root = TreeNode ( ls [ rootIndex ]) if rootIndex 0 : root . left = self . constructTree ( ls [ 0 : rootIndex ]) if rootIndex len ( ls ) - 1 : root . right = self . constructTree ( ls [ rootIndex + 1 : ]) return root def findMaxIndex ( self , ls ): maxx , index = ls [ 0 ], 0 for s in range ( len ( ls )): if ls [ s ] maxx : maxx , index = ls [ s ], s return index \u5783\u573e\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from utils.BinaryTree import * class Solution : def constructMaximumBinaryTree ( self , nums ) - TreeNode : if len ( nums ) == 0 : return max_index = 0 record = [] for i in range ( len ( nums )): record . append ( TreeNode ( nums [ i ])) if nums [ i ] = nums [ max_index ]: max_index = i for i in range ( 1 , len ( record )): if nums [ i ] nums [ i - 1 ]: record [ i ] . left = self . constructMaximumBinaryTree ( nums [: i ]) elif nums [ i ] nums [ i - 1 ]: record [ i - 1 ] . right = record [ i ] return record [ max_index ] 655 Todo \u6253\u5370\u4e8c\u53c9\u6811 \u5176\u4ed6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution ( object ): def printTree ( self , root ): :type root: TreeNode :rtype: List[List[str]] if root is None : return [ ] def depth ( root ): if root is None : return 0 return max ( depth ( root . left ), depth ( root . right )) + 1 d = depth ( root ) self . ans = [[ ] * ( 2 ** d - 1 ) for _ in range ( d )] def helper ( node , d , pos ): self . ans [ - d - 1 ][ pos ] = str ( node . val ) if node . left : helper ( node . left , d - 1 , pos - 2 ** ( d - 1 )) if node . right : helper ( node . right , d - 1 , pos + 2 ** ( d - 1 )) helper ( root , d - 1 , 2 ** ( d - 1 ) - 1 ) return self . ans","title":"651 660"},{"location":"LeetCode/vol 6/651-660/#654","text":"\u6839\u636e\u4e00\u4e2a\u6570\u7ec4\uff0c\u6784\u5efa\u4e00\u4e2a\u4e8c\u53c9\u6811 \u6839\u8282\u70b9\u7684\u503c\u65f6\u8be5\u6570\u7ec4\u7684\u6700\u5927\u503c\uff0c\u5de6\u8fb9\u662f\u7531\u6700\u5927\u503c\u5de6\u8fb9\u90e8\u5206\u6784\u9020\u7684\u7684\u6700\u5927\u6570\uff0c\u53f3\u8fb9\u540c\u7406 1 2 3 4 5 6 7 8 9 10 Input: [3,2,1,6,0,5] Output: return the tree root node representing the following tree: 6 / \\ 3 5 \\ / 2 0 \\ 1 \u60f3\u6cd5 \u9012\u5f52\uff1f \u6216\u8005\u662f\u904d\u5386\uff1f \u5bf9\u4e8e\u6570\u7ec4\u7684\u6bcf\u4e2a\u503c\uff0c\u5982\u679c\u540e\u9762\u7684\u503c\u6bd4\u4e4b\u524d\u7684\u5927\uff0c\u90a3\u4e48TreeNode(vals[i+1]).left = TreeNode(vals[i])\uff0c\u7136\u540e\u8fd9\u6837\u904d\u5386\u4e0b\u53bb\uff1f\u5148\u8bd5\u8bd5\uff1f \u4e0d\u8fc7\u611f\u89c9\u8fd9\u9996\u5148\u9700\u8981\u628a\u6240\u6709\u7684\u8282\u70b9\u5148\u8bb0\u5f55\u4e0b\u6765\uff0c \u8bb0\u5f55\u5f15\u7528\uff1f \uff0c\u5b9e\u9645\u4e0a\u6548\u679c\u53ef\u80fd\u5e76\u4e0d\u597d\uff0c\u540c\u65f6\uff0c\u8fd8\u9700\u8981\u56de\u6eaf\u51fa\u4e4b\u524d\u7684\u6700\u5927\u6811\u7684\u8282\u70b9 \u770b\u6765\u8fd8\u662f\u7528\u9012\u5f52\u6bd4\u8f83\u597d","title":"654"},{"location":"LeetCode/vol 6/651-660/#_1","text":"\u7b80\u5355\u7684\u9012\u5f52\uff0c\u80fd\u5426\u8fdb\u4e00\u6b65\u4f18\u5316\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def constructMaximumBinaryTree ( self , nums ) - TreeNode : if len ( nums ) == 0 : return return self . __buildTree ( nums , 0 , len ( nums )) def __buildTree ( self , nums , start , end ): if start = end : return idx_max = start for i in range ( start + 1 , end ): if nums [ i ] nums [ idx_max ]: idx_max = i root = TreeNode ( nums [ idx_max ]) root . left = self . __buildTree ( nums , start , idx_max ) root . right = self . __buildTree ( nums , idx_max + 1 , end ) return root","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 6/651-660/#_2","text":"\u5988\u7684\u6ca1\u533a\u522b\u554a\uff0c\u4e3a\u4ec0\u4e48\u90a3\u4e48\u5feb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def constructMaximumBinaryTree ( self , nums : List[int] ) - TreeNode : return self . constructTree ( nums ) def constructTree ( self , ls ): rootIndex = self . findMaxIndex ( ls ) root = TreeNode ( ls [ rootIndex ]) if rootIndex 0 : root . left = self . constructTree ( ls [ 0 : rootIndex ]) if rootIndex len ( ls ) - 1 : root . right = self . constructTree ( ls [ rootIndex + 1 : ]) return root def findMaxIndex ( self , ls ): maxx , index = ls [ 0 ], 0 for s in range ( len ( ls )): if ls [ s ] maxx : maxx , index = ls [ s ], s return index","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 6/651-660/#_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from utils.BinaryTree import * class Solution : def constructMaximumBinaryTree ( self , nums ) - TreeNode : if len ( nums ) == 0 : return max_index = 0 record = [] for i in range ( len ( nums )): record . append ( TreeNode ( nums [ i ])) if nums [ i ] = nums [ max_index ]: max_index = i for i in range ( 1 , len ( record )): if nums [ i ] nums [ i - 1 ]: record [ i ] . left = self . constructMaximumBinaryTree ( nums [: i ]) elif nums [ i ] nums [ i - 1 ]: record [ i - 1 ] . right = record [ i ] return record [ max_index ]","title":"\u5783\u573e\u4ee3\u7801"},{"location":"LeetCode/vol 6/651-660/#655","text":"Todo \u6253\u5370\u4e8c\u53c9\u6811","title":"655"},{"location":"LeetCode/vol 6/651-660/#_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution ( object ): def printTree ( self , root ): :type root: TreeNode :rtype: List[List[str]] if root is None : return [ ] def depth ( root ): if root is None : return 0 return max ( depth ( root . left ), depth ( root . right )) + 1 d = depth ( root ) self . ans = [[ ] * ( 2 ** d - 1 ) for _ in range ( d )] def helper ( node , d , pos ): self . ans [ - d - 1 ][ pos ] = str ( node . val ) if node . left : helper ( node . left , d - 1 , pos - 2 ** ( d - 1 )) if node . right : helper ( node . right , d - 1 , pos + 2 ** ( d - 1 )) helper ( root , d - 1 , 2 ** ( d - 1 ) - 1 ) return self . ans","title":"\u5176\u4ed6"},{"location":"LeetCode/vol 7/701-710/","text":"701 \u5f80\u4e8c\u53c9\u641c\u7d22\u6811\u4e2d\u63d2\u5165\u4e00\u4e2a\u503c \u6cd5\u4e00 \u76f4\u63a5\u66b4\u529b\u63d2\u5165 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def insertIntoBST ( self , root : TreeNode , val : int ) - TreeNode : p = root while p : if val p . val : if p . right : p = p . right else : p . right = TreeNode ( val ) break elif val p . val : if p . left : p = p . left else : p . left = TreeNode ( val ) break return root \u6cd5\u4e8c \u6216\u8005\u9012\u5f52 1 2 3 4 5 6 7 8 9 class Solution : def insertIntoBST ( self , root : TreeNode , val : int ) - TreeNode : if not root : return TreeNode ( val ) if root . val val : root . left = self . insertIntoBST ( root . left , val ) else : root . right = self . insertIntoBST ( root . right , val ) return root","title":"701 710"},{"location":"LeetCode/vol 7/701-710/#701","text":"\u5f80\u4e8c\u53c9\u641c\u7d22\u6811\u4e2d\u63d2\u5165\u4e00\u4e2a\u503c","title":"701"},{"location":"LeetCode/vol 7/701-710/#_1","text":"\u76f4\u63a5\u66b4\u529b\u63d2\u5165 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def insertIntoBST ( self , root : TreeNode , val : int ) - TreeNode : p = root while p : if val p . val : if p . right : p = p . right else : p . right = TreeNode ( val ) break elif val p . val : if p . left : p = p . left else : p . left = TreeNode ( val ) break return root","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 7/701-710/#_2","text":"\u6216\u8005\u9012\u5f52 1 2 3 4 5 6 7 8 9 class Solution : def insertIntoBST ( self , root : TreeNode , val : int ) - TreeNode : if not root : return TreeNode ( val ) if root . val val : root . left = self . insertIntoBST ( root . left , val ) else : root . right = self . insertIntoBST ( root . right , val ) return root","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 8/811-820/","text":"814 \u7ed9\u5b9a\u4e00\u4e2a\u6811\uff0c\u6811\u7684\u8282\u70b9\u53ea\u6709\u4e24\u4e2a\u503c\uff0c0\u62161 \u5b9e\u73b0\u4e00\u4e2a\u526a\u679d\u7b97\u6cd5\uff0c\u5c06\u8be5\u6811\u7684\u6240\u6709\u4e0d\u5305\u542b1\u7684\u5b50\u6811\u526a\u679d 1 2 3 4 5 6 7 8 9 10 11 12 Example 1: Input: [1,null,0,0,1] Output: [1,null,0,null,1] 1 0 0 1 | | 1 0 1 \u60f3\u6cd5 \u9012\u5f52\u54af \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 1 0 1 0 0 0 1 \u589e\u52a0\u4e00\u6b21\u6e05\u6d17\uff0c\u628a\u5de6\u5b50\u6811\u76840\u7ed9\u53bb\u6389 1 0 1 1 \u600e\u4e48\u4f18\u5316\u5462 1 2 3 4 5 6 7 8 9 10 11 class Solution : def pruneTree ( self , root : TreeNode ) - TreeNode : if not root : return root if ( not root . left ) and ( not root . right ) and root . val == 0 : return None else : root . left = self . pruneTree ( root . left ) root . left = self . pruneTree ( root . left ) root . right = self . pruneTree ( root . right ) return root \u4f18\u5316 \u8fd8\u662f\u903b\u8f91\u6709\u95ee\u9898\uff0c\u5148\u6e05\u7406\u5b50\u6811\uff0c\u5728\u6e05\u7406\u81ea\u5df1 1 2 3 4 5 6 7 8 9 class Solution : def pruneTree ( self , root : TreeNode ) - TreeNode : if not root : return root root . left = self . pruneTree ( root . left ) root . right = self . pruneTree ( root . right ) if ( not root . left ) and ( not root . right ) and root . val == 0 : return None return root","title":"811 820"},{"location":"LeetCode/vol 8/811-820/#814","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6811\uff0c\u6811\u7684\u8282\u70b9\u53ea\u6709\u4e24\u4e2a\u503c\uff0c0\u62161 \u5b9e\u73b0\u4e00\u4e2a\u526a\u679d\u7b97\u6cd5\uff0c\u5c06\u8be5\u6811\u7684\u6240\u6709\u4e0d\u5305\u542b1\u7684\u5b50\u6811\u526a\u679d 1 2 3 4 5 6 7 8 9 10 11 12 Example 1: Input: [1,null,0,0,1] Output: [1,null,0,null,1] 1 0 0 1 | | 1 0 1 \u60f3\u6cd5 \u9012\u5f52\u54af","title":"814"},{"location":"LeetCode/vol 8/811-820/#_1","text":"1 2 3 4 5 6 7 8 9 1 0 1 0 0 0 1 \u589e\u52a0\u4e00\u6b21\u6e05\u6d17\uff0c\u628a\u5de6\u5b50\u6811\u76840\u7ed9\u53bb\u6389 1 0 1 1 \u600e\u4e48\u4f18\u5316\u5462 1 2 3 4 5 6 7 8 9 10 11 class Solution : def pruneTree ( self , root : TreeNode ) - TreeNode : if not root : return root if ( not root . left ) and ( not root . right ) and root . val == 0 : return None else : root . left = self . pruneTree ( root . left ) root . left = self . pruneTree ( root . left ) root . right = self . pruneTree ( root . right ) return root \u4f18\u5316 \u8fd8\u662f\u903b\u8f91\u6709\u95ee\u9898\uff0c\u5148\u6e05\u7406\u5b50\u6811\uff0c\u5728\u6e05\u7406\u81ea\u5df1 1 2 3 4 5 6 7 8 9 class Solution : def pruneTree ( self , root : TreeNode ) - TreeNode : if not root : return root root . left = self . pruneTree ( root . left ) root . right = self . pruneTree ( root . right ) if ( not root . left ) and ( not root . right ) and root . val == 0 : return None return root","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 8/871-880/","text":"874 \u673a\u5668\u4eba\u5728\u4e00\u4e2a\u65e0\u9650\u5927\u5c0f\u7684\u7f51\u683c\u4e0a\u884c\u8d70\uff0c\u4ece\u70b9(0, 0)\u5904\u5f00\u59cb\u51fa\u53d1\uff0c\u9762\u5411\u5317\u65b9\u3002\u8be5\u673a\u5668\u4eba\u53ef\u4ee5\u63a5\u6536\u4ee5\u4e0b\u4e09\u79cd\u7c7b\u578b\u7684\u547d\u4ee4\uff1a 1 2 3 4 5 -2\uff1a\u5411\u5de6\u8f6c 90 \u5ea6 -1\uff1a\u5411\u53f3\u8f6c 90 \u5ea6 1 = x = 9\uff1a\u5411\u524d\u79fb\u52a8 x \u4e2a\u5355\u4f4d\u957f\u5ea6 \u5728\u7f51\u683c\u4e0a\u6709\u4e00\u4e9b\u683c\u5b50\u88ab\u89c6\u4e3a\u969c\u788d\u7269\u3002 \u7b2c i \u4e2a\u969c\u788d\u7269\u4f4d\u4e8e\u7f51\u683c\u70b9 (obstacles[i][0], obstacles[i][1]) \u5982\u679c\u673a\u5668\u4eba\u8bd5\u56fe\u8d70\u5230\u969c\u788d\u7269\u4e0a\u65b9\uff0c\u90a3\u4e48\u5b83\u5c06\u505c\u7559\u5728\u969c\u788d\u7269\u7684\u524d\u4e00\u4e2a\u7f51\u683c\u65b9\u5757\u4e0a\uff0c\u4f46\u4ecd\u7136\u53ef\u4ee5\u7ee7\u7eed\u8be5\u8def\u7ebf\u7684\u5176\u4f59\u90e8\u5206\u3002 \u8fd4\u56de\u4ece\u539f\u70b9\u5230\u673a\u5668\u4eba\u7684\u6700\u5927\u6b27\u5f0f\u8ddd\u79bb\u7684\u5e73\u65b9 \u60f3\u6cd5 \u5148\u66b4\u529b\u8bd5\u8bd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def robotSim ( self , commands , obstacles ) - int : currentX , currentY = 0 , 0 forward = [[ 0 , 1 ], [ 1 , 0 ], [ 0 , - 1 ], [ - 1 , 0 ]] currentForward = 0 res = 0 for command in commands : if command 0 : for tick in range ( command ): if [ currentX + forward [ currentForward ][ 0 ] * 1 , currentY + forward [ currentForward ][ 1 ] * 1 ] not in obstacles : currentX , currentY = currentX + forward [ currentForward ][ 0 ] * 1 , currentY + \\ forward [ currentForward ][ 1 ] * 1 res = max ( res , currentX ** 2 + currentY ** 2 ) if command == - 1 : currentForward = ( currentForward + 1 ) % 4 elif command == - 2 : currentForward = ( currentForward - 1 ) % 4 return res \u66b4\u529b\u8d85\u65f6\u4e86 \u4e8e\u662f\u5c1d\u8bd5\u5bf9 obstacles \u4f18\u5316 \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def robotSim ( self , commands , obstacles ) - int : currentX , currentY = 0 , 0 obstacles = set ( map ( tuple , obstacles )) forward = [[ 0 , 1 ], [ 1 , 0 ], [ 0 , - 1 ], [ - 1 , 0 ]] currentForward = 0 res = 0 for command in commands : if command 0 : for tick in range ( command ): if ( currentX + forward [ currentForward ][ 0 ] * 1 , currentY + forward [ currentForward ][ 1 ] * 1 ) not in obstacles : currentX , currentY = currentX + forward [ currentForward ][ 0 ] * 1 , currentY + \\ forward [ currentForward ][ 1 ] * 1 res = max ( res , currentX ** 2 + currentY ** 2 ) if command == - 1 : currentForward = ( currentForward + 1 ) % 4 elif command == - 2 : currentForward = ( currentForward - 1 ) % 4 return res \u6cd5\u4e8c Todo \u601d\u8def\u4e00\u81f4\uff0c\u4e3a\u4ec0\u4e48\u6cd5\u4e00\u6548\u7387\u90a3\u4e48\u5dee\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def robotSim ( self , commands : List[int] , obstacles : List[List[int]] ) - int : obs = set (( x , y ) for x , y in obstacles ) x , y , d , sol = 0 , 0 , 0 , 0 dx , dy = 0 , 1 for c in commands : if c == - 2 : dx , dy = - dy , dx elif c == - 1 : dx , dy = dy , - dx else : for _ in range ( c ): if ( x + dx , y + dy ) in obs : break x += dx y += dy sol = max ( sol , x * x + y * y ) return sol","title":"871 880"},{"location":"LeetCode/vol 8/871-880/#874","text":"\u673a\u5668\u4eba\u5728\u4e00\u4e2a\u65e0\u9650\u5927\u5c0f\u7684\u7f51\u683c\u4e0a\u884c\u8d70\uff0c\u4ece\u70b9(0, 0)\u5904\u5f00\u59cb\u51fa\u53d1\uff0c\u9762\u5411\u5317\u65b9\u3002\u8be5\u673a\u5668\u4eba\u53ef\u4ee5\u63a5\u6536\u4ee5\u4e0b\u4e09\u79cd\u7c7b\u578b\u7684\u547d\u4ee4\uff1a 1 2 3 4 5 -2\uff1a\u5411\u5de6\u8f6c 90 \u5ea6 -1\uff1a\u5411\u53f3\u8f6c 90 \u5ea6 1 = x = 9\uff1a\u5411\u524d\u79fb\u52a8 x \u4e2a\u5355\u4f4d\u957f\u5ea6 \u5728\u7f51\u683c\u4e0a\u6709\u4e00\u4e9b\u683c\u5b50\u88ab\u89c6\u4e3a\u969c\u788d\u7269\u3002 \u7b2c i \u4e2a\u969c\u788d\u7269\u4f4d\u4e8e\u7f51\u683c\u70b9 (obstacles[i][0], obstacles[i][1]) \u5982\u679c\u673a\u5668\u4eba\u8bd5\u56fe\u8d70\u5230\u969c\u788d\u7269\u4e0a\u65b9\uff0c\u90a3\u4e48\u5b83\u5c06\u505c\u7559\u5728\u969c\u788d\u7269\u7684\u524d\u4e00\u4e2a\u7f51\u683c\u65b9\u5757\u4e0a\uff0c\u4f46\u4ecd\u7136\u53ef\u4ee5\u7ee7\u7eed\u8be5\u8def\u7ebf\u7684\u5176\u4f59\u90e8\u5206\u3002 \u8fd4\u56de\u4ece\u539f\u70b9\u5230\u673a\u5668\u4eba\u7684\u6700\u5927\u6b27\u5f0f\u8ddd\u79bb\u7684\u5e73\u65b9 \u60f3\u6cd5 \u5148\u66b4\u529b\u8bd5\u8bd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def robotSim ( self , commands , obstacles ) - int : currentX , currentY = 0 , 0 forward = [[ 0 , 1 ], [ 1 , 0 ], [ 0 , - 1 ], [ - 1 , 0 ]] currentForward = 0 res = 0 for command in commands : if command 0 : for tick in range ( command ): if [ currentX + forward [ currentForward ][ 0 ] * 1 , currentY + forward [ currentForward ][ 1 ] * 1 ] not in obstacles : currentX , currentY = currentX + forward [ currentForward ][ 0 ] * 1 , currentY + \\ forward [ currentForward ][ 1 ] * 1 res = max ( res , currentX ** 2 + currentY ** 2 ) if command == - 1 : currentForward = ( currentForward + 1 ) % 4 elif command == - 2 : currentForward = ( currentForward - 1 ) % 4 return res \u66b4\u529b\u8d85\u65f6\u4e86 \u4e8e\u662f\u5c1d\u8bd5\u5bf9 obstacles \u4f18\u5316","title":"874"},{"location":"LeetCode/vol 8/871-880/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def robotSim ( self , commands , obstacles ) - int : currentX , currentY = 0 , 0 obstacles = set ( map ( tuple , obstacles )) forward = [[ 0 , 1 ], [ 1 , 0 ], [ 0 , - 1 ], [ - 1 , 0 ]] currentForward = 0 res = 0 for command in commands : if command 0 : for tick in range ( command ): if ( currentX + forward [ currentForward ][ 0 ] * 1 , currentY + forward [ currentForward ][ 1 ] * 1 ) not in obstacles : currentX , currentY = currentX + forward [ currentForward ][ 0 ] * 1 , currentY + \\ forward [ currentForward ][ 1 ] * 1 res = max ( res , currentX ** 2 + currentY ** 2 ) if command == - 1 : currentForward = ( currentForward + 1 ) % 4 elif command == - 2 : currentForward = ( currentForward - 1 ) % 4 return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 8/871-880/#_2","text":"Todo \u601d\u8def\u4e00\u81f4\uff0c\u4e3a\u4ec0\u4e48\u6cd5\u4e00\u6548\u7387\u90a3\u4e48\u5dee\uff1f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def robotSim ( self , commands : List[int] , obstacles : List[List[int]] ) - int : obs = set (( x , y ) for x , y in obstacles ) x , y , d , sol = 0 , 0 , 0 , 0 dx , dy = 0 , 1 for c in commands : if c == - 2 : dx , dy = - dy , dx elif c == - 1 : dx , dy = dy , - dx else : for _ in range ( c ): if ( x + dx , y + dy ) in obs : break x += dx y += dy sol = max ( sol , x * x + y * y ) return sol","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 9/921-930/","text":"929 \u7ed9\u5b9a\u4e00\u7ec4email\u7684\u5b57\u7b26\u4e32\uff0c\u6839\u636e\u89c4\u5219\u6e05\u6d17\uff0c\u8fd4\u56de\u6e05\u6d17\u540e\u7684\u6709\u6548email\u5730\u5740\u4e2a\u6570 \u89c4\u5219 localname\u4e2d\uff0c . \u5ffd\u7565\uff0c + \u540e\u7684localname\u5ffd\u7565\uff0c\u4fdd\u7559domainname \u6cd5\u4e00 \u66b4\u529b\u5b8c\u6210 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def numUniqueEmails ( self , emails ) - int : res = set () for email in emails : cleanString = [] i = 0 while i len ( email ) and email [ i ] != @ : if email [ i ] == . : i += 1 elif email [ i ] == + : while email [ i ] != @ : i += 1 else : cleanString . append ( email [ i ]) i += 1 cleanString += email [ i :] res . add ( . join ( cleanString )) return len ( res ) \u6cd5\u4e8c 1 2 3 4 5 6 7 8 9 10 class Solution : def numUniqueEmails ( self , emails : List[str] ) - int : res = set () for email in emails : name , domain = email . split ( @ ) name = name . split ( + )[ 0 ] name = name . replace ( . , ) res . add ( {}@{} . format ( name , domain )) return len ( res )","title":"921 930"},{"location":"LeetCode/vol 9/921-930/#929","text":"\u7ed9\u5b9a\u4e00\u7ec4email\u7684\u5b57\u7b26\u4e32\uff0c\u6839\u636e\u89c4\u5219\u6e05\u6d17\uff0c\u8fd4\u56de\u6e05\u6d17\u540e\u7684\u6709\u6548email\u5730\u5740\u4e2a\u6570 \u89c4\u5219 localname\u4e2d\uff0c . \u5ffd\u7565\uff0c + \u540e\u7684localname\u5ffd\u7565\uff0c\u4fdd\u7559domainname","title":"929"},{"location":"LeetCode/vol 9/921-930/#_1","text":"\u66b4\u529b\u5b8c\u6210 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def numUniqueEmails ( self , emails ) - int : res = set () for email in emails : cleanString = [] i = 0 while i len ( email ) and email [ i ] != @ : if email [ i ] == . : i += 1 elif email [ i ] == + : while email [ i ] != @ : i += 1 else : cleanString . append ( email [ i ]) i += 1 cleanString += email [ i :] res . add ( . join ( cleanString )) return len ( res )","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 9/921-930/#_2","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def numUniqueEmails ( self , emails : List[str] ) - int : res = set () for email in emails : name , domain = email . split ( @ ) name = name . split ( + )[ 0 ] name = name . replace ( . , ) res . add ( {}@{} . format ( name , domain )) return len ( res )","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 9/931-940/","text":"938 \u7ed9\u5b9a\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u6839\u8282\u70b9\uff0c\u8fd4\u56deL\u548cR\uff08\u5305\u62ec\uff09\u4e4b\u95f4\u7684\u503c\u7684\u6240\u6709\u8282\u70b9\u7684\u503c\u7684\u603b\u548c\u3002 \u4e8c\u8fdb\u5236\u641c\u7d22\u6811\u4fdd\u8bc1\u5177\u6709\u552f\u4e00\u503c 1 2 3 4 5 6 Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32 10 5 15 3 7 None 18 \u60f3\u6cd5 \u60f3\u8981\u5f97\u5230\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u7684\u8282\u70b9\uff0c\u9700\u8981\u904d\u5386 \u4e8c\u53c9\u641c\u7d22\u6570\uff0c \u4e2d\u5e8f\u904d\u5386\uff1f \u6cd5\u4e00 1 2 3 4 5 6 7 8 9 10 11 class Solution : def rangeSumBST ( self , root : TreeNode , L : int , R : int ) - int : return self . midOrder ( root , 0 , L , R ) def midOrder ( self , root : TreeNode , res , L , R ): if root : res = self . midOrder ( root . left , res , L , R ) if root . val = L and root . val = R : res += root . val res = self . midOrder ( root . right , res , L , R ) return res \u6cd5\u4e8c \u8fd9\u91cc\u4f7f\u7528stack\u51cf\u5c11\u4e86\u904d\u5386\u7684\u6b21\u6570 \u8fd9\u91cc\u7a0d\u5fae\u6709\u70b9\u8ff7\u7cca 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def rangeSumBST ( self , root : TreeNode , L : int , R : int ) - int : stack = [ root ] ans = 0 while stack : node = stack . pop () if node : # \u7b26\u5408\u8981\u6c42\u7684 if L = node . val = R : ans += node . val if L node . val : stack . append ( node . left ) if node . val R : stack . append ( node . right ) return ans","title":"931 940"},{"location":"LeetCode/vol 9/931-940/#938","text":"\u7ed9\u5b9a\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u6839\u8282\u70b9\uff0c\u8fd4\u56deL\u548cR\uff08\u5305\u62ec\uff09\u4e4b\u95f4\u7684\u503c\u7684\u6240\u6709\u8282\u70b9\u7684\u503c\u7684\u603b\u548c\u3002 \u4e8c\u8fdb\u5236\u641c\u7d22\u6811\u4fdd\u8bc1\u5177\u6709\u552f\u4e00\u503c 1 2 3 4 5 6 Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32 10 5 15 3 7 None 18 \u60f3\u6cd5 \u60f3\u8981\u5f97\u5230\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u7684\u8282\u70b9\uff0c\u9700\u8981\u904d\u5386 \u4e8c\u53c9\u641c\u7d22\u6570\uff0c \u4e2d\u5e8f\u904d\u5386\uff1f","title":"938"},{"location":"LeetCode/vol 9/931-940/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def rangeSumBST ( self , root : TreeNode , L : int , R : int ) - int : return self . midOrder ( root , 0 , L , R ) def midOrder ( self , root : TreeNode , res , L , R ): if root : res = self . midOrder ( root . left , res , L , R ) if root . val = L and root . val = R : res += root . val res = self . midOrder ( root . right , res , L , R ) return res","title":"\u6cd5\u4e00"},{"location":"LeetCode/vol 9/931-940/#_2","text":"\u8fd9\u91cc\u4f7f\u7528stack\u51cf\u5c11\u4e86\u904d\u5386\u7684\u6b21\u6570 \u8fd9\u91cc\u7a0d\u5fae\u6709\u70b9\u8ff7\u7cca 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def rangeSumBST ( self , root : TreeNode , L : int , R : int ) - int : stack = [ root ] ans = 0 while stack : node = stack . pop () if node : # \u7b26\u5408\u8981\u6c42\u7684 if L = node . val = R : ans += node . val if L node . val : stack . append ( node . left ) if node . val R : stack . append ( node . right ) return ans","title":"\u6cd5\u4e8c"},{"location":"LeetCode/vol 9/941-950/","text":"950 Todo \u9898\u76ee\u662f\u7279\u6b8a\u7684\u6392\u5e8f\u624b\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 Input: [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7] Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order doesn t matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom. The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom. The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom. The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom. The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom. The deck is now [13,17]. We reveal 13, and move 17 to the bottom. The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct. \u60f3\u6cd5 \u9996\u5148\u5148\u81ea\u5df1\u6392\u4e2a\u5e8f\uff1f \u9700\u8981\u4f7f\u7528\u961f\u5217","title":"941 950"},{"location":"LeetCode/vol 9/941-950/#950","text":"Todo \u9898\u76ee\u662f\u7279\u6b8a\u7684\u6392\u5e8f\u624b\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 Input: [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7] Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order doesn t matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom. The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom. The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom. The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom. The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom. The deck is now [13,17]. We reveal 13, and move 17 to the bottom. The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct. \u60f3\u6cd5 \u9996\u5148\u5148\u81ea\u5df1\u6392\u4e2a\u5e8f\uff1f \u9700\u8981\u4f7f\u7528\u961f\u5217","title":"950"},{"location":"SDN\u4e0eOpenFlow\u89e3\u6790/\u96c6\u4e2d\u5f0f\u4e0e\u5206\u5e03\u5f0f\u7684\u63a7\u5236\u5e73\u9762\u548c\u6570\u636e\u5e73\u9762/","text":"\u96c6\u4e2d\u5f0f\u4e0e\u5206\u5e03\u5f0f\u7684\u63a7\u5236\u5e73\u9762\u4e0e\u6570\u636e\u5e73\u9762 \u57fa\u7840\u77e5\u8bc6 SDN\u539f\u5219\u5305\u542b\u4e86 \u5c06\u7f51\u7edc\u8bbe\u5907\u7684\u63a7\u5236\u4e0e\u6570\u636e\u5e73\u9762\u7684\u5206\u79bb \uff0c\u8be5\u64cd\u4f5c\u80fd\u5e26\u6765\u6f5c\u5728\u7684\u4f18\u52bf \u90a3\u4e48\u95ee\u9898\u6765\u4e86\uff0c\u5206\u79bb\u4e4b\u540e\u5e94\u8be5\u591a\u8fdc\uff1f\u591a\u5c11\u5b9e\u529b\u624d\u80fd\u6ee1\u8db3\u6545\u969c\u7684\u6062\u590d\u80fd\u529b\u4e0e\u9ad8\u53ef\u7528\u6027\u7684\u9700\u6c42\uff1f \u63a7\u5236\u5e73\u9762\u4e0e\u6570\u636e\u5e73\u9762 \u63a7\u5236\u5e73\u9762 \u63a7\u5236\u5e73\u9762\u5728\u672c\u5730\u5efa\u7acb\u7528\u4e8e\u521b\u5efa\u8f6c\u53d1\u8868\u9879\u7684\u6570\u636e\u96c6\uff0c\u6570\u636e\u5e73\u9762\u5229\u7528\u8f6c\u53d1\u8868\u9879\u5728\u8bbe\u5907\u7684\u51fa\u5165\u7aef\u53e3\u4e4b\u95f4\u8f6c\u53d1\u6d41\u91cf \u4fdd\u5b58\u4e86\u7f51\u7edc\u62ec\u6251\u7684\u6570\u636e\u96c6\u6210\u4e3a\u8def\u7531\u4fe1\u606f\u5e93RIB \u4fdd\u5b58\u4e86\u8f6c\u53d1\u8868\u9879\u5219\u79f0\u4e3a\u8f6c\u53d1\u4fe1\u606f\u5e93FIB","title":"\u96c6\u4e2d\u5f0f\u4e0e\u5206\u5e03\u5f0f\u7684\u63a7\u5236\u5e73\u9762\u4e0e\u6570\u636e\u5e73\u9762"},{"location":"SDN\u4e0eOpenFlow\u89e3\u6790/\u96c6\u4e2d\u5f0f\u4e0e\u5206\u5e03\u5f0f\u7684\u63a7\u5236\u5e73\u9762\u548c\u6570\u636e\u5e73\u9762/#_1","text":"","title":"\u96c6\u4e2d\u5f0f\u4e0e\u5206\u5e03\u5f0f\u7684\u63a7\u5236\u5e73\u9762\u4e0e\u6570\u636e\u5e73\u9762"},{"location":"SDN\u4e0eOpenFlow\u89e3\u6790/\u96c6\u4e2d\u5f0f\u4e0e\u5206\u5e03\u5f0f\u7684\u63a7\u5236\u5e73\u9762\u548c\u6570\u636e\u5e73\u9762/#_2","text":"SDN\u539f\u5219\u5305\u542b\u4e86 \u5c06\u7f51\u7edc\u8bbe\u5907\u7684\u63a7\u5236\u4e0e\u6570\u636e\u5e73\u9762\u7684\u5206\u79bb \uff0c\u8be5\u64cd\u4f5c\u80fd\u5e26\u6765\u6f5c\u5728\u7684\u4f18\u52bf \u90a3\u4e48\u95ee\u9898\u6765\u4e86\uff0c\u5206\u79bb\u4e4b\u540e\u5e94\u8be5\u591a\u8fdc\uff1f\u591a\u5c11\u5b9e\u529b\u624d\u80fd\u6ee1\u8db3\u6545\u969c\u7684\u6062\u590d\u80fd\u529b\u4e0e\u9ad8\u53ef\u7528\u6027\u7684\u9700\u6c42\uff1f","title":"\u57fa\u7840\u77e5\u8bc6"},{"location":"SDN\u4e0eOpenFlow\u89e3\u6790/\u96c6\u4e2d\u5f0f\u4e0e\u5206\u5e03\u5f0f\u7684\u63a7\u5236\u5e73\u9762\u548c\u6570\u636e\u5e73\u9762/#_3","text":"","title":"\u63a7\u5236\u5e73\u9762\u4e0e\u6570\u636e\u5e73\u9762"},{"location":"SDN\u4e0eOpenFlow\u89e3\u6790/\u96c6\u4e2d\u5f0f\u4e0e\u5206\u5e03\u5f0f\u7684\u63a7\u5236\u5e73\u9762\u548c\u6570\u636e\u5e73\u9762/#_4","text":"\u63a7\u5236\u5e73\u9762\u5728\u672c\u5730\u5efa\u7acb\u7528\u4e8e\u521b\u5efa\u8f6c\u53d1\u8868\u9879\u7684\u6570\u636e\u96c6\uff0c\u6570\u636e\u5e73\u9762\u5229\u7528\u8f6c\u53d1\u8868\u9879\u5728\u8bbe\u5907\u7684\u51fa\u5165\u7aef\u53e3\u4e4b\u95f4\u8f6c\u53d1\u6d41\u91cf \u4fdd\u5b58\u4e86\u7f51\u7edc\u62ec\u6251\u7684\u6570\u636e\u96c6\u6210\u4e3a\u8def\u7531\u4fe1\u606f\u5e93RIB \u4fdd\u5b58\u4e86\u8f6c\u53d1\u8868\u9879\u5219\u79f0\u4e3a\u8f6c\u53d1\u4fe1\u606f\u5e93FIB","title":"\u63a7\u5236\u5e73\u9762"}]}